[{"path":"https://robinhankin.github.io/lorentz/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robin K. S. Hankin. Author, maintainer.","code":""},{"path":"https://robinhankin.github.io/lorentz/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hankin RK (2023). lorentz: Lorentz Transform Relativistic Physics. https://github.com/RobinHankin/lorentz, https://robinhankin.github.io/lorentz/.","code":"@Manual{,   title = {lorentz: The Lorentz Transform in Relativistic Physics},   author = {Robin K. S. Hankin},   year = {2023},   note = {https://github.com/RobinHankin/lorentz, https://robinhankin.github.io/lorentz/}, }"},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"The Lorentz Transform in Relativistic Physics","text":"lorentz package furnishes R-centric functionality special relativity. Lorentz transformations four-vectors handled functionality stress energy tensor given. package deals four-momentum facilities dealing photons mirrors relativistic situations. detailed vignette provided package. original motivation package investigation (nonassociative) gyrogroup structure relativistic three-velocities Einsteinian velocity composition. Natural R idiom may used manipulate vectors three-velocities, although one must careful brackets.","code":""},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"The Lorentz Transform in Relativistic Physics","text":"install recent stable version CRAN, use install.packages() R prompt: install current development version use devtools: load package use library():","code":"R> install.packages(\"lorentz\") R> devtools::install_github(\"RobinHankin/lorentz\") library(\"lorentz\")"},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"the-lorentz-package-in-use","dir":"","previous_headings":"","what":"The lorentz package in use","title":"The Lorentz Transform in Relativistic Physics","text":"package furnishes natural R idiom working three-velocities, four-velocities, Lorentz transformations four--four matrices. Although natural units  used default, can changed. boost matrix can used transform arbitrary four-vectors: can also used transform four-velocities: classical parallelogram law addition velocities incorrect relativistic effects included. combine   terms successive boosts simply multiply boost matrices: note result depends order:","code":"u <- as.3vel(c(0.6,0,0))  # define a three-velocity, 0.6c to the right  u #> A vector of three-velocities (speed of light = 1) #>        x y z #> [1,] 0.6 0 0 as.4vel(u)    # convert to a four-velocity: #> A vector of four-velocities (speed of light = 1) #>         t    x y z #> [1,] 1.25 0.75 0 0 gam(u)  # calculate the gamma term #> [1] 1.25 B <- boost(u) # give the Lorentz transformation B #>       t     x y z #> t  1.25 -0.75 0 0 #> x -0.75  1.25 0 0 #> y  0.00  0.00 1 0 #> z  0.00  0.00 0 1 B %*% (1:4)  # Lorentz transform of an arbitrary four-vector #>    [,1] #> t -0.25 #> x  1.75 #> y  3.00 #> z  4.00 v <- as.4vel(c(0,0.7,-0.2)) B %*% t(v) #>        [,1] #> t  1.823312 #> x -1.093987 #> y  1.021055 #> z -0.291730 boost(u) %*% boost(v) #>           t     x          y          z #> t  1.823312 -0.75 -1.2763187  0.3646625 #> x -1.093987  1.25  0.7657912 -0.2187975 #> y -1.021055  0.00  1.4240348 -0.1211528 #> z  0.291730  0.00 -0.1211528  1.0346151 boost(v) %*% boost(u) #>            t          x          y          z #> t  1.8233124 -1.0939874 -1.0210549  0.2917300 #> x -0.7500000  1.2500000  0.0000000  0.0000000 #> y -1.2763187  0.7657912  1.4240348 -0.1211528 #> z  0.3646625 -0.2187975 -0.1211528  1.0346151"},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"vectorization","dir":"","previous_headings":"","what":"Vectorization","title":"The Lorentz Transform in Relativistic Physics","text":"package fully vectorized can deal vectors whose entries three-velocities four-velocities:","code":"set.seed(0)  options(digits=3)  # generate 5 random three-velocities:  (u <- r3vel(5)) #> A vector of three-velocities (speed of light = 1) #>           x       y      z #> [1,]  0.230  0.0719  0.314 #> [2,] -0.311  0.4189 -0.277 #> [3,] -0.185  0.5099 -0.143 #> [4,] -0.739 -0.4641  0.129 #> [5,] -0.304 -0.2890  0.593  # calculate the gamma correction term:  gam(u) #> [1] 1.09 1.24 1.21 2.13 1.46  # add a velocity of 0.9c in the x-direction:  v <- as.3vel(c(0.9,0,0))  v+u #> A vector of three-velocities (speed of light = 1) #>          x      y      z #> [1,] 0.936  0.026  0.113 #> [2,] 0.818  0.253 -0.168 #> [3,] 0.858  0.267 -0.075 #> [4,] 0.480 -0.605  0.168 #> [5,] 0.820 -0.174  0.356  # convert u to a four-velocity:  as.4vel(u) #> A vector of four-velocities (speed of light = 1) #>         t      x       y      z #> [1,] 1.09  0.250  0.0783  0.341 #> [2,] 1.24 -0.385  0.5190 -0.343 #> [3,] 1.21 -0.223  0.6160 -0.173 #> [4,] 2.13 -1.571 -0.9862  0.273 #> [5,] 1.46 -0.443 -0.4209  0.864  # use four-velocities to effect the same transformation:  w <- as.4vel(u) %*% boost(-v)  as.3vel(w) #> A vector of three-velocities (speed of light = 1) #>          x      y      z #> [1,] 0.936  0.026  0.113 #> [2,] 0.818  0.253 -0.168 #> [3,] 0.858  0.267 -0.075 #> [4,] 0.480 -0.605  0.168 #> [5,] 0.820 -0.174  0.356"},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"three-velocities","dir":"","previous_headings":"","what":"Three-velocities","title":"The Lorentz Transform in Relativistic Physics","text":"Three-velocites behave interesting counter-intuitive ways. three-velocity addition law given Ungar. can see velocity addition commutative: Observe difference u+v v+u “small” sense. Commutativity replaced gyrocommutatitivity: (, zero numerical accuracy)","code":"u <- as.3vel(c(0.2,0.4,0.1))   # single three-velocity  v <- r3vel(4,0.9)              # 4 random three-velocities with speed 0.9  w <- as.3vel(c(-0.5,0.1,0.3))  # single three-velocity u+v #> A vector of three-velocities (speed of light = 1) #>           x      y     z #> [1,]  0.702 -0.113 0.567 #> [2,] -0.679  0.580 0.102 #> [3,] -0.046  0.879 0.364 #> [4,]  0.312  0.407 0.788  v+u #> A vector of three-velocities (speed of light = 1) #>           x      y     z #> [1,]  0.624 -0.378 0.543 #> [2,] -0.823  0.358 0.045 #> [3,] -0.234  0.832 0.401 #> [4,]  0.228  0.190 0.892  (u+v)-(v+u) #> A vector of three-velocities (speed of light = 1) #>          x     y       z #> [1,] 0.243 0.506  0.1190 #> [2,] 0.201 0.490  0.1206 #> [3,] 0.503 0.245 -0.0519 #> [4,] 0.242 0.564 -0.1105 # Compare two different ways of calculating the same thing:  (u+v) - gyr(u,v,v+u)   #> A vector of three-velocities (speed of light = 1) #>              x         y         z #> [1,]  3.53e-15 -1.20e-15  2.89e-15 #> [2,]  2.89e-16 -3.18e-15 -1.08e-16 #> [3,] -4.26e-15  1.09e-13  4.67e-14 #> [4,]  1.67e-15  4.76e-16  1.91e-15 # The other way round:  (v+u) - gyr(v,u,u+v) #> A vector of three-velocities (speed of light = 1) #>             x         y         z #> [1,] 3.21e-15 -6.42e-16  2.89e-15 #> [2,] 3.76e-15 -1.73e-15 -2.53e-16 #> [3,] 1.47e-14 -4.07e-14 -2.03e-14 #> [4,] 9.05e-15  6.43e-15  3.24e-14"},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"nonassociativity-of-three-velocities","dir":"","previous_headings":"","what":"Nonassociativity of three-velocities","title":"The Lorentz Transform in Relativistic Physics","text":"reasonable expect u+(v+w)==(u+v)+w. However, case: (, significant departure associativity). Associativity replaced gyroassociativity: (zero numerical accuracy).","code":"((u+v)+w) - (u+(v+w)) #> A vector of three-velocities (speed of light = 1) #>             x       y         z #> [1,]  0.00613  0.0794 -0.001467 #> [2,] -0.11096 -0.1508 -0.031226 #> [3,] -0.10748 -0.1022  0.000795 #> [4,] -0.05772 -0.0631 -0.007364 (u+(v+w)) - ((u+v)+gyr(u,v,w)) #> A vector of three-velocities (speed of light = 1) #>      x         y         z #> [1,] 0  8.16e-17 -6.53e-16 #> [2,] 0 -9.49e-16  0.00e+00 #> [3,] 0  3.21e-15  1.60e-15 #> [4,] 0  0.00e+00  0.00e+00  ((u+v)+w) - (u+(v+gyr(v,u,w))) #> A vector of three-velocities (speed of light = 1) #>              x         y         z #> [1,]  0.00e+00  4.03e-17 -1.29e-15 #> [2,] -1.81e-15  9.07e-16  0.00e+00 #> [3,]  0.00e+00  1.37e-14  5.48e-15 #> [4,]  0.00e+00 -1.84e-15 -1.84e-15"},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"The Lorentz Transform in Relativistic Physics","text":"concise reference . . Ungar 2006. Thomas precession: kinematic effect algebra Einstein’s velocity addition law. Comments “Deriving relativistic momentum energy: II, Three-dimensional case. European Journal Physics, 27:L17-L20","code":""},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"further-information","dir":"","previous_headings":"","what":"Further information","title":"The Lorentz Transform in Relativistic Physics","text":"detail, see package vignette","code":"vignette(\"lorentz\")"},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":null,"dir":"Reference","previous_headings":"","what":"Three velocities — 3vel","title":"Three velocities — 3vel","text":"Create test three-velocities, 3vel objects.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Three velocities — 3vel","text":"","code":"`3vel`(n) threevel(n) as.3vel(x) is.3vel(x) # S3 method for vec length(x) # S3 method for vec names(x) # S3 method for vec names(x) <- value"},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Three velocities — 3vel","text":"n function 3vel(), number three velocities     create x,value Vectors three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Three velocities — 3vel","text":"Class vel virtual class containing classes 3vel   4vel. Function threevel() convenience wrapper 3vel().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Three velocities — 3vel","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Three velocities — 3vel","text":"","code":"U <- r4vel(7) as.4vel(as.3vel(U)) # equal to U, to numerical precision #> A vector of four-velocities (speed of light = 1) #>             t          x          y          z #> [1,] 1.454682  0.5007084  0.7877018 -0.4948902 #> [2,] 2.874297 -1.6009875  1.9400491  0.9667630 #> [3,] 1.344230  0.2948148  0.5961823  0.6038259 #> [4,] 1.782010 -1.1630198 -0.8775076 -0.2300547 #> [5,] 1.180753 -0.2481616  0.5251170  0.2384234 #> [6,] 3.181337  1.6702438  1.0818393 -2.2717429 #> [7,] 3.020545  0.9170428  2.6902977  0.2121925  x <- as.3vel(1:3/4) u <- as.3vel(matrix(runif(30)/10,ncol=3))  names(u) <- letters[1:10]  x+u #> A vector of three-velocities (speed of light = 1) #>           x         y         z #> a 0.2635815 0.5125677 0.7500347 #> b 0.2550150 0.4929731 0.7663985 #> c 0.2550058 0.5176115 0.7522024 #> d 0.2614593 0.4997678 0.7527761 #> e 0.2489055 0.5192752 0.7486195 #> f 0.2648140 0.5090069 0.7569210 #> g 0.2681603 0.5048553 0.7459455 #> h 0.2703278 0.5166842 0.7429878 #> i 0.2632699 0.5120974 0.7473982 #> j 0.2651336 0.5006366 0.7493894 u+x  # not equal #> A vector of three-velocities (speed of light = 1) #>           x         y         z #> a 0.2843791 0.5257343 0.7331336 #> b 0.2589571 0.4675575 0.7808669 #> c 0.2580821 0.5387748 0.7361205 #> d 0.2803447 0.4938917 0.7498523 #> e 0.2418847 0.5466509 0.7312294 #> f 0.2866137 0.5113850 0.7473165 #> g 0.2997320 0.5090219 0.7309453 #> h 0.3043009 0.5384244 0.7138422 #> i 0.2843719 0.5266043 0.7293691 #> j 0.2912785 0.4974897 0.7417399"},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":null,"dir":"Reference","previous_headings":"","what":"Four momentum — 4mom","title":"Four momentum — 4mom","text":"Create test four-momentum","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Four momentum — 4mom","text":"","code":"# S3 method for 4mom Ops(e1, e2) # S3 method for 4mom sum(..., na.rm=FALSE) vel_to_4mom(U,m=1) p_to_4mom(p,E=1) as.4mom(x) is.4mom(x) fourmom_mult(P,n) fourmom_add(e1,e2)"},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Four momentum — 4mom","text":"x,P,e1,e2 Four-momentum p Three-momentum E Scalar; energy U Object coerced four-velocity m Scalar; rest mass n Multiplying factor ...,na.rm Arguments sent sum()","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Four momentum — 4mom","text":"Four-momentum relativistic generalization three-momentum, object's energy first element.  can defined \\(mU\\), \\(m\\) rest mass \\(U\\) four-velocity. Equivalently, one can define four-momentum \\((E/c,p_x,p_y,p_z)\\) \\(E\\) energy \\((p_x,p_y,p_z)\\) three-momentum. Function vel_to_4mom() converts three-velocity four-momentum, function p_to_4mom()) converts three-momentum four-momentum. function Ops.4mom() passes unary binary arithmetic operators “+”, “-” “*” appropriate specialist function. package designed natural R idiom may used physically meaningful operations combining momenta different objects, using conservation four-momentum. four-momentum photon, use .photon().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Four momentum — 4mom","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Four momentum — 4mom","text":"","code":"# Define 5 random three velocities: v <- r3vel(5)  # convert to four-velocity: as.4vel(v) #> A vector of four-velocities (speed of light = 1) #>              t            x           y          z #> [1,]  1.278524   0.36199530   0.6477667  0.2897961 #> [2,]  2.454848   0.05034919   1.3662014 -1.7768613 #> [3,] 42.202639 -31.11404021 -28.0264935  5.1473230 #> [4,]  1.817919  -1.47357952   0.1674720 -0.3245727 #> [5,]  1.255114  -0.38861127   0.5759494 -0.3042625  # Now convert 'v' to four-momentum, specifying rest mass: vel_to_4mom(v)         # 4mom of five objects with 3vel v, all unit mass #>              E          p_x         p_y        p_z #> [1,]  1.278524   0.36199530   0.6477667  0.2897961 #> [2,]  2.454848   0.05034919   1.3662014 -1.7768613 #> [3,] 42.202639 -31.11404021 -28.0264935  5.1473230 #> [4,]  1.817919  -1.47357952   0.1674720 -0.3245727 #> [5,]  1.255114  -0.38861127   0.5759494 -0.3042625 vel_to_4mom(v,   1:5)  # 4mom of five objects with 3vel v, masses 1-5 #>               E         p_x         p_y        p_z #> [1,]   1.278524   0.3619953   0.6477667  0.2897961 #> [2,]   4.909696   0.1006984   2.7324028 -3.5537227 #> [3,] 126.607918 -93.3421206 -84.0794804 15.4419689 #> [4,]   7.271678  -5.8943181   0.6698879 -1.2982909 #> [5,]   6.275572  -1.9430564   2.8797468 -1.5213127 vel_to_4mom(v[1],1:5)  # 4mom of five objects with same 3vel, masses 1..5 #>             E       p_x       p_y       p_z #> [1,] 1.278524 0.3619953 0.6477667 0.2897961 #> [2,] 2.557048 0.7239906 1.2955334 0.5795922 #> [3,] 3.835572 1.0859859 1.9433000 0.8693883 #> [4,] 5.114097 1.4479812 2.5910667 1.1591843 #> [5,] 6.392621 1.8099765 3.2388334 1.4489804  # Now convert 'v' to four-momentum, specifying energy E: p_to_4mom(v,E=1) #>      E         p_x         p_y        p_z #> [1,] 1  0.28313528  0.50665188  0.2266645 #> [2,] 1  0.02051011  0.55653202 -0.7238173 #> [3,] 1 -0.73725342 -0.66409338  0.1219668 #> [4,] 1 -0.81058573  0.09212288 -0.1785408 #> [5,] 1 -0.30962220  0.45888197 -0.2424182 p_to_4mom(v,E=10)   # slower #>       E         p_x         p_y        p_z #> [1,] 10  0.28313528  0.50665188  0.2266645 #> [2,] 10  0.02051011  0.55653202 -0.7238173 #> [3,] 10 -0.73725342 -0.66409338  0.1219668 #> [4,] 10 -0.81058573  0.09212288 -0.1785408 #> [5,] 10 -0.30962220  0.45888197 -0.2424182 p_to_4mom(v,E=100)  # even slower #>        E         p_x         p_y        p_z #> [1,] 100  0.28313528  0.50665188  0.2266645 #> [2,] 100  0.02051011  0.55653202 -0.7238173 #> [3,] 100 -0.73725342 -0.66409338  0.1219668 #> [4,] 100 -0.81058573  0.09212288 -0.1785408 #> [5,] 100 -0.30962220  0.45888197 -0.2424182  # Four-momentum of objects moving closely parallel to the x-axis: P <- vel_to_4mom(as.3vel(c(0.8,0,0)) + r3vel(7,0.01))  reflect(P) #>             E       p_x           p_y          p_z #> [1,] 1.673589 -1.341948  0.0014432416 -0.008462948 #> [2,] 1.655888 -1.319822 -0.0016394959  0.005563373 #> [3,] 1.674509 -1.343098  0.0071301797  0.003912783 #> [4,] 1.661364 -1.326667  0.0002920382  0.009143552 #> [5,] 1.678148 -1.347647 -0.0035265593 -0.003807818 #> [6,] 1.667390 -1.334200 -0.0005179104  0.009975552 #> [7,] 1.660300 -1.325337 -0.0055117041  0.006799182 reflect(P,c(1,1,1)) #>             E       p_x        p_y        p_z #> [1,] 1.673589 0.4426363 -0.9007552 -0.8908490 #> [2,] 1.655888 0.4425566 -0.8756259 -0.8828288 #> [3,] 1.674509 0.4550614 -0.8951671 -0.8919497 #> [4,] 1.661364 0.4485127 -0.8784463 -0.8872978 #> [5,] 1.678148 0.4443262 -0.8997945 -0.8995132 #> [6,] 1.667390 0.4510383 -0.8826433 -0.8931368 #> [7,] 1.660300 0.4426374 -0.8771882 -0.8894991  sum(P) #>             E     p_x        p_y         p_z #> [1,] 11.67119 9.33872 0.00233021 -0.02312368"},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":null,"dir":"Reference","previous_headings":"","what":"Four velocities — 4vel","title":"Four velocities — 4vel","text":"Create test four-velocities.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Four velocities — 4vel","text":"","code":"as.4vel(u) is.consistent.4vel(U, give=FALSE, TOL=1e-10) inner4(U,V=U) to3(U)"},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Four velocities — 4vel","text":"u vector three-velocities U,V vector four-velocities give function .consistent.4vel(), Boolean     TRUE meaning return \\(U\\cdot U+c^2\\),     zero four-velocity, default FALSE meaning return     whether four-velocity consistent numerical precision TOL Small positive value used tolerance","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Four velocities — 4vel","text":"Function .4vel() takes three-velocity returns   four-velocity. Given four-vector \\(V\\), function inner4() returns   Lorentz invariant \\(V^iV_i=\\eta_{ij}V^iV^j\\).    quantity unchanged Lorentz transforms.  Note function   inner4() works four-vector, just four-velocities.   work (eg) four-displacement, four-momentum vector   four-frequency.  electromagnetism, four-current   four-potential.  \\(U\\) four-velocity,   \\(U^iU_i=-c^2\\); \\(U\\) 4-displacement, \\(U^iU_i\\)   squared interval.  \\(P\\) four-momentum photon   \\(P^iP_i=0\\). Function to3() low-level helper function used   .3vel() given four-velocity. Function .consistent.4vel() checks four-velocities   consistent sense \\(U^iU_i=-c^2\\).  Giving   function vector, example, .consistent.4vel(1:5),   return error. Compare functions documented boost(),   returns \\(4\\times 4\\) transformation matrix (also   includes rotation information).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Four velocities — 4vel","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Four velocities — 4vel","text":"","code":"a <- r3vel(10) as.4vel(a)     # a four-velocity #> A vector of four-velocities (speed of light = 1) #>              t           x           y           z #>  [1,] 1.028493  0.14281353  0.09757529 -0.16697715 #>  [2,] 1.218253  0.21084290  0.27055498 -0.60538003 #>  [3,] 1.727776  0.85680469  1.02681143  0.44356806 #>  [4,] 1.629724 -0.05037851  1.21438749 -0.42275768 #>  [5,] 1.023055 -0.02868603  0.20209681  0.07054033 #>  [6,] 1.398565 -0.45234205  0.26403176 -0.82562639 #>  [7,] 1.216016 -0.61421604 -0.24736161  0.20061626 #>  [8,] 1.626005 -0.68205940 -0.73933888  0.79502461 #>  [9,] 5.471295 -3.18677766  3.78159136 -2.11638468 #> [10,] 1.393087  0.60366703 -0.11232715  0.75077262  as.3vel(as.4vel(a))-a   # zero to numerical precision #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,] -2.798355e-17 -6.881201e-18  1.376240e-17 #>  [2,]  5.149144e-18 -5.149144e-17  8.238630e-17 #>  [3,] -8.285618e-17 -3.314247e-16 -8.285618e-17 #>  [4,] -4.607424e-18  0.000000e+00  3.685939e-17 #>  [5,] -1.248249e-18  8.170355e-18  1.043990e-17 #>  [6,]  2.714475e-17 -4.071712e-17  5.428949e-17 #>  [7,]  4.104206e-17  1.026051e-17 -1.539077e-17 #>  [8,]  0.000000e+00 -7.338272e-17  0.000000e+00 #>  [9,]  0.000000e+00  0.000000e+00  0.000000e+00 #> [10,] -1.346625e-16  6.733124e-18 -5.386499e-17  inner4(as.4vel(a))   #  -1 to numerical precision #>  [1] -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  stopifnot(all(is.consistent.4vel(as.4vel(a))))   ## check Lorentz invariance of dot product: U <- as.4vel(r3vel(10)) V <- as.4vel(r3vel(10)) B <- boost(as.3vel(1:3/10))  frame1dotprod <- inner4(U, V) frame2dotprod <- inner4(U %*% B, V %*% B) max(abs(frame1dotprod-frame2dotprod))  # zero to numerical precision #> [1] 3.552714e-15"},{"path":"https://robinhankin.github.io/lorentz/reference/Extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract or replace parts of three-velocity — Extract.3vel","title":"Extract or replace parts of three-velocity — Extract.3vel","text":"Extract replace subsets three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract or replace parts of three-velocity — Extract.3vel","text":"x three-vector index elements extract replace value replacement value","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Extract.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract or replace parts of three-velocity — Extract.3vel","text":"methods () work expected: object class 3vel three-column matrix rows corresponding three-velocities; single argument interpreted row number. Salient use-cases u[1:5] <- u[1] u[1] <- 0. extract single component, pass second index: u[,1] returns x- component three-velocity. Extraction functions take drop argument, except x[] returns vec object. Currently, u[] returns u sure desirable.  Maybe return unclass(u) perhaps c(unclass(u)). Use idiom u[] <- x replace entries u elementwise.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Extract.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract or replace parts of three-velocity — Extract.3vel","text":"","code":"u <- r3vel(10) u[1:4] #> A vector of three-velocities (speed of light = 1) #>                x          y          z #> [1,]  0.02915101  0.5726896  0.3631669 #> [2,] -0.48656733 -0.4916248 -0.6238993 #> [3,] -0.38446050 -0.1006253  0.4787119 #> [4,] -0.09316058 -0.4705715  0.1075096 u[5:6] <- 0  u[7:8] <- u[1]  u[,1] <- 0.1"},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"Arithmetic operations three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"","code":"# S3 method for 3vel Ops(e1, e2) # S3 method for 4vel Ops(e1, e2) massage3(u,v) neg3(u) prod3(u,v=u) add3(u,v) dot3(v,r)"},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"e1,e2,u,v Objects class “3vel”,     three-velocities r Scalar value circle-dot multiplication","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"function Ops.3vel() passes unary binary arithmetic   operators “+”, “-” “*”   appropriate specialist function. interesting operators “+”   “*”, passed add3() dot3()   respectively.  defined, following Ungar, : $$     \\mathbf{u}+\\mathbf{v} = \\frac{1}{1+\\mathbf{u}\\cdot\\mathbf{b}/c^2}     \\left\\{     \\mathbf{u} +     \\frac{1}{\\gamma_\\mathbf{u}}\\mathbf{v} +     \\frac{1}{c^2}\\frac{\\gamma_\\mathbf{u}}{1+\\gamma_\\mathbf{u}}     \\left(\\mathbf{u}\\cdot\\mathbf{v}\\right)\\mathbf{u}     \\right\\}   $$ $$     r\\odot\\mathbf{v} =     c\\tanh\\left(     r\\tanh^{-1}\\frac{\\left|\\left|\\mathbf{v}\\right|\\right|}{c}     \\right)\\frac{\\mathbf{v}}{\\left|\\left|\\mathbf{v}\\right|\\right|}   $$ \\(\\mathbf{u}\\) \\(\\mathbf{v}\\) three-vectors   \\(r\\) scalar.  Function dot3() special dispensation   zero velocity treat NA entries entirely   consistently. Arithmetic operations, executed via Ops.4vel(), defined   four-velocities. package designed natural R idiom may used three   velocity addition, see examples section.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"Returns object class 3vel, except prod3() returns numeric vector.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"","code":"u <- as.3vel(c(-0.7, 0.1,-0.1)) v <- as.3vel(c( 0.1, 0.2, 0.3)) w <- as.3vel(c( 0.5, 0.2,-0.3))  x <- r3vel(10)   # random three velocities y <- r3vel(10)   # random three velocities   u+v   # add3(u,v) #> A vector of three-velocities (speed of light = 1) #>              x         y         z #> [1,] -0.648977 0.2557545 0.1246803 u-v   # add3(u,neg3(v)) #> A vector of three-velocities (speed of light = 1) #>               x           y          z #> [1,] -0.7434641 -0.03267974 -0.2913943  -v    # neg3(v) #> A vector of three-velocities (speed of light = 1) #>         x    y    z #> [1,] -0.1 -0.2 -0.3  gyr(u,v,w) #> A vector of three-velocities (speed of light = 1) #>              x         y          z #> [1,] 0.5134003 0.2390541 -0.2434611  ## package is vectorized:   u+x #> A vector of three-velocities (speed of light = 1) #>                x            y           z #>  [1,] -0.6814637  0.456142182 -0.33540844 #>  [2,] -0.8826071  0.315732883  0.30247641 #>  [3,] -0.9309375 -0.134325013  0.16747172 #>  [4,] -0.9474883 -0.003628649  0.17751063 #>  [5,] -0.7242842 -0.190756369 -0.54099823 #>  [6,] -0.6981999 -0.331042175 -0.33175517 #>  [7,] -0.6015094  0.079414124 -0.39425778 #>  [8,] -0.9352654  0.119271619  0.22314224 #>  [9,] -0.1404583 -0.701477560 -0.38954743 #> [10,] -0.2480934  0.587816178  0.07772347 x+y #> A vector of three-velocities (speed of light = 1) #>                 x          y           z #>  [1,]  0.09069208  0.4383420 -0.76816683 #>  [2,] -0.50708992  0.1556891  0.84559885 #>  [3,] -0.85121558 -0.1582477  0.45032707 #>  [4,] -0.55004905 -0.2491420  0.77233518 #>  [5,]  0.62679174 -0.6803857 -0.08534592 #>  [6,] -0.24796439 -0.7142885 -0.52992334 #>  [7,] -0.24929014 -0.7883021  0.53930187 #>  [8,] -0.82029194  0.3678137  0.38882122 #>  [9,]  0.76883858 -0.5995835 -0.10072980 #> [10,]  0.46462600 -0.1566096 -0.56618744  f <- gyrfun(u,v) g <- gyrfun(v,u)  f(g(x)) - x    # should be zero by eqn10 #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,]  3.956250e-16 -1.245246e-15  6.226229e-16 #>  [2,] -4.958462e-15  3.856581e-15  3.856581e-15 #>  [3,] -1.488052e-15  9.300322e-17  1.116039e-15 #>  [4,]  4.033448e-16  3.529267e-16 -4.033448e-16 #>  [5,] -3.957648e-16  0.000000e+00 -1.623650e-16 #>  [6,] -1.026622e-16  5.054137e-16  3.285189e-16 #>  [7,] -2.960572e-16  8.818724e-17  1.595769e-16 #>  [8,] -1.169889e-15  7.311807e-17  2.339778e-16 #>  [9,]  2.930242e-16 -5.860483e-16 -7.325604e-17 #> [10,] -3.481156e-16  2.900963e-16  4.351444e-17 g(f(x)) - x #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,]  3.461719e-16 -6.745082e-16  5.707377e-16 #>  [2,]  8.815043e-15 -7.162222e-15 -1.101880e-14 #>  [3,]  2.790097e-16  7.440258e-16 -5.580193e-16 #>  [4,]  4.033448e-16  5.041810e-16  3.025086e-16 #>  [5,] -7.103470e-17  8.118251e-17  4.870951e-16 #>  [6,] -1.737360e-16  3.537896e-16  2.527069e-17 #>  [7,] -2.099696e-16  9.711095e-17  1.763745e-16 #>  [8,]  0.000000e+00  1.608597e-16 -4.679556e-16 #>  [9,] -2.930242e-16  0.000000e+00  7.325604e-17 #> [10,] -4.061348e-16  0.000000e+00  2.755915e-16   (u+v) - f(v+u)                     # zero by eqn 10 #> A vector of three-velocities (speed of light = 1) #>                  x            y            z #> [1,] -6.132309e-16 1.951189e-16 1.672448e-16 (u+(v+w)) - ((u+v)+f(w))           # zero by eqn 11 #> A vector of three-velocities (speed of light = 1) #>                  x y             z #> [1,] -5.469679e-17 0 -5.469679e-18 ((u+v)+w) - (u+(v+g(w)))           # zero by eqn 11 #> A vector of three-velocities (speed of light = 1) #>                 x            y            z #> [1,] 3.951349e-16 -2.99021e-16 1.975675e-16   ## NB, R idiom is unambiguous.  But always always ALWAYS use brackets.  ## Ice report in lat 42.n to 41.25n Long 49w to long 50.30w saw much ## heavy pack ice and great number large icebergs also field ## ice.  Weather good clear  ## -u+v == (-u) + v == neg3(u) + v == add3(neg3(u),v)  ## u+v+w == (u+v)+w == add3(add3(u,v),w)"},{"path":"https://robinhankin.github.io/lorentz/reference/as.matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","title":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","text":"Coerce 3-vectors 4-vectors matrix.  convenience wrapper unclass()","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/as.matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","text":"","code":"# S3 method for 3vel as.matrix(x, ...) # S3 method for 4vel as.matrix(x, ...)"},{"path":"https://robinhankin.github.io/lorentz/reference/as.matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","text":"x Object class 3vel 4vel ... arguments (currently ignored)","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/as.matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/as.matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","text":"","code":"as.matrix(r3vel(5)) #>               x           y           z #> [1,] -0.6841281  0.08659297 -0.28632305 #> [2,]  0.5444297  0.79750699  0.08842427 #> [3,] -0.0414655  0.69861818  0.48084846 #> [4,]  0.1541881 -0.71487499 -0.27314649 #> [5,] -0.5762641  0.36595219  0.59687095 as.matrix(r4vel(5)) #>             t          x          y          z #> [1,] 2.177634 -1.8920127 -0.3692378 -0.1613685 #> [2,] 1.267500 -0.6377395 -0.4151849  0.1657269 #> [3,] 1.800106  0.3968333 -1.4390077  0.1102814 #> [4,] 1.082793  0.1106622  0.1044897  0.3863623 #> [5,] 1.173366  0.4662360 -0.2973897 -0.2664060"},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":null,"dir":"Reference","previous_headings":"","what":"Lorentz transformations — boost","title":"Lorentz transformations — boost","text":"Lorentz transformations: boosts rotations","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lorentz transformations — boost","text":"","code":"boost(u=0) rot(u,v,space=TRUE) is.consistent.boost(L, give=FALSE, TOL=1e-10) is.consistent.boost.galilean(L, give=FALSE, TOL=1e-10) pureboost(L,include_sol=TRUE) orthog(L) pureboost.galilean(L, tidy=TRUE) orthog.galilean(L)"},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lorentz transformations — boost","text":"u,v Three-velocities, coerced  class 3vel.      function boost(), u takes special default value     0, interpreted zero three velocity L Lorentz transform expressed \\(4\\times 4\\) matrix TOL Numerical tolerance give Boolean TRUE meaning return transformed     metric tensor (flat-space eta(); qv)     default FALSE meaning return whether matrix     consistent boost space Boolean, default TRUE meaning return just     spatial component rotation matrix FALSE     meaning return full \\(4\\times 4\\) matrix     transformation tidy pureboost.galilean(), Boolean default     TRUE meaning return “tidy” boost matrix     spatial components forced \\(3\\times 3\\) identity     matrix include_sol function pureboost(), Boolean     default TRUE meaning correctly account speed     light, FALSE meaning assume \\(c=1\\). See details","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lorentz transformations — boost","text":"Function boost() returns \\(4\\times 4\\) matrix; function rot() returns orthogonal matrix.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lorentz transformations — boost","text":"Arguments u,v coerced three-velocities. rotation-free Lorentz transformation known boost   (sometimes pure boost), expressed matrix form.  Pure   boost matrices symmetric \\(c=1\\).  Function boost(u)   returns \\(4\\times 4\\) matrix giving Lorentz transform   arbitrary three-velocity u. Boosts can successively applied regular matrix multiplication.   However, composing two successive pure boosts general   return pure boost matrix: product symmetric general.   Also note boost matrices commute.  resulting matrix   product represents Lorentz transform. possible decompose Lorentz transform \\(L\\) pure   boost spatial rotation.  Thus \\(L=OP\\) \\(O\\)   orthogonal matrix \\(P\\) pure boost matrix; returned   functions orthog() pureboost() respectively.     speed light equal 1, functions still work can   confusing. Functions pureboost.galilean() orthog.galilean()   Newtonian equivalents pureboost() orthog(),   intended used speed light infinite (causes   problems relativistic functions). noted , composition two pure Lorentz boosts   necessarily pure.  two successive boosts corresponding   \\(u\\) \\(v\\), composed boost may decomposed   pure boost boost(u+v) rotation rot(u,v). reason argument include_sol exists function   orthog() needs call pureboost() environment   pretend \\(c=1\\).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lorentz transformations — boost","text":"Ungar 2006. “Thomas precession: kinematic       effect...”. European Journal Physics, 27:L17-L20 Sbitneva 2001. “Nonassociative geometry special relativity”.     International Journal Theoretical Physics, volume 40, number 1,       pages 359--362 Wikipedia contributors 2018.  “Wigner rotation”,   Wikipedia, Free Encyclopedia.   https://en.wikipedia.org/w/index.php?title=Wigner_rotation&oldid=838661305.  Online; accessed 23 August 2018","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Lorentz transformations — boost","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Lorentz transformations — boost","text":"Function rot() uses crossprod() efficiency reasons algebraically equivalent boost(-u-v) %*% boost(u) %*% boost(v).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lorentz transformations — boost","text":"","code":"boost(as.3vel(c(0.4,-0.2,0.1))) #>            t           x           y           z #> t  1.1250879 -0.45003516  0.22501758 -0.11250879 #> x -0.4500352  1.09530507 -0.04765253  0.02382627 #> y  0.2250176 -0.04765253  1.02382627 -0.01191313 #> z -0.1125088  0.02382627 -0.01191313  1.00595657  u <- r3vel(1) v <- r3vel(1) w <- r3vel(1)  boost(u) - solve(boost(-u))  # should be zero #>               t             x             y             z #> t -2.664535e-15  3.552714e-15  4.440892e-16  1.110223e-15 #> x  2.664535e-15 -3.552714e-15 -4.440892e-16 -1.110223e-15 #> y  4.440892e-16 -4.440892e-16  4.440892e-16 -5.551115e-17 #> z  1.110223e-15 -8.881784e-16 -5.551115e-17 -2.220446e-16  boost(u) %*% boost(v)   # not a pure boost (not symmetrical) #>            t          x         y         z #> t  11.167182 -7.1013290  4.008128 -7.563861 #> x -10.420873  6.9491345 -3.655007  6.924237 #> y   1.964453 -0.9189521  1.619977 -1.179100 #> z  -3.354442  1.5145728 -1.040043  2.979373 boost(u+v)  # not the same! #>            t          x          y          z #> t  11.167182 -10.420873  1.9644532 -3.3544422 #> x -10.420873   9.925205 -1.6825028  2.8729920 #> y   1.964453  -1.682503  1.3171709 -0.5415917 #> z  -3.354442   2.872992 -0.5415917  1.9248060 boost(v+u)  # also not the same! #>           t         x         y         z #> t 11.167182 -7.101329  4.008128 -7.563861 #> x -7.101329  5.144663 -2.339328  4.414618 #> y  4.008128 -2.339328  2.320362 -2.491696 #> z -7.563861  4.414618 -2.491696  5.702156  u+v  # returns a three-velocity #> A vector of three-velocities (speed of light = 1) #>              x          y         z #> [1,] 0.9331694 -0.1759131 0.3003839   boost(u) %*% boost(v) %*% boost(w)  # associative, no brackets needed #>            t          x          y          z #> t  40.399635 -28.301384  14.881020 -24.672199 #> x -37.906860  26.817543 -13.844936  22.957943 #> y   7.127139  -4.656671   3.536945  -4.195420 #> z -11.975156   7.816849  -4.272298   8.065278 boost(u+(v+w))  # not the same! #>            t          x         y          z #> t  40.399635 -37.906860  7.127139 -11.975156 #> x -37.906860  35.708761 -6.525842  10.964845 #> y   7.127139  -6.525842  2.226970  -2.061579 #> z -11.975156  10.964845 -2.061579   4.463904 boost((u+v)+w)  # also not the same! #>            t          x         y          z #> t  39.031482 -36.320734  7.241135 -12.281159 #> x -36.320734  33.953956 -6.569912  11.142748 #> y   7.241135  -6.569912  2.309820  -2.221490 #> z -12.281159  11.142748 -2.221490   4.767706   rot(u,v) #>            x           y          z #> x  0.8670320 -0.22214993 0.44598765 #> y  0.2275934  0.97284471 0.04212362 #> z -0.4432345  0.06498133 0.89404732 rot(v,u)    # transpose (=inverse) of rot(u,v) #>            x          y           z #> x  0.8670320 0.22759342 -0.44323449 #> y -0.2221499 0.97284471  0.06498133 #> z  0.4459877 0.04212362  0.89404732   rot(u,v,FALSE) %*% boost(v) %*% boost(u) #>            t          x          y          z #> t  11.167182 -10.420873  1.9644532 -3.3544422 #> x -10.420873   9.925205 -1.6825028  2.8729920 #> y   1.964453  -1.682503  1.3171709 -0.5415917 #> z  -3.354442   2.872992 -0.5415917  1.9248060 boost(u+v)     # should be the same. #>            t          x          y          z #> t  11.167182 -10.420873  1.9644532 -3.3544422 #> x -10.420873   9.925205 -1.6825028  2.8729920 #> y   1.964453  -1.682503  1.3171709 -0.5415917 #> z  -3.354442   2.872992 -0.5415917  1.9248060   orthog(boost(u) %*% boost(v)) - rot(u,v,FALSE)  # zero to numerical precision #>               t             x             y             z #> t -3.651746e-11 -2.331512e-11  1.317976e-11 -2.486177e-11 #> x -3.428802e-11 -2.189593e-11  1.234277e-11 -2.330602e-11 #> y  6.473540e-12  4.135997e-12 -2.329581e-12  4.400730e-12 #> z -1.103549e-11 -7.041645e-12  3.969672e-12 -7.490453e-12 pureboost(boost(v) %*% boost(u)) - boost(u+v)   # ditto #>               t             x             y             z #> t  1.739053e-12  2.035705e-12 -3.832490e-13  6.545875e-13 #> x  2.035705e-12  1.532996e-12 -2.895462e-13  4.947154e-13 #> y -3.830269e-13 -2.895462e-13  5.395684e-14 -9.314771e-14 #> z  6.541434e-13  4.947154e-13 -9.314771e-14  1.592060e-13   ## Define a random-ish Lorentz transform L <- boost(r3vel(1)) %*% boost(r3vel(1)) %*% boost(r3vel(1))  ## check it:   if (FALSE)    # needs emulator package quad.form(eta(),L)  # should be eta()   ## More concisely: is.consistent.boost(L)     # should be TRUE #> [1] FALSE  ## Decompose L into a rotation and a pure boost: U <- orthog(L) P <- pureboost(L)  L - U %*% P              # should be zero (L = UP) #>               t             x             y             z #> t -6.065818e-09 -1.237808e-09  5.588277e-09 -2.008335e-09 #> x -2.294911e-09 -4.675265e-10  2.114518e-09 -7.595062e-10 #> y  1.586852e-08  3.243073e-09 -1.460859e-08  5.280242e-09 #> z  9.278381e-09  1.890093e-09 -8.542742e-09  3.088161e-09 crossprod(U)               # should be identity (U is orthogonal) #>               t             x             y             z #> t  9.997290e-01  5.538645e-05 -2.494844e-04  9.027651e-05 #> x  5.538645e-05  9.999887e-01  5.098255e-05 -1.844815e-05 #> y -2.494844e-04  5.098255e-05  9.997704e-01  8.309843e-05 #> z  9.027651e-05 -1.844815e-05  8.309843e-05  9.999699e-01 P - t(P)                   # should be zero (P is symmetric) #>               t x y            z #> t  0.000000e+00 0 0 2.842171e-14 #> x  0.000000e+00 0 0 0.000000e+00 #> y  0.000000e+00 0 0 0.000000e+00 #> z -2.842171e-14 0 0 0.000000e+00  ## First row of P should be a consistent 4-velocity: is.consistent.4vel(P[1,,drop=FALSE],give=TRUE) #>             t  #> -0.0002711451"},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"Combines arguments recursively form vector three velocities four velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"","code":"# S3 method for 3vel c(...) # S3 method for 3cel c(...) # S3 method for 4vel c(...)"},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"... Vectors three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"Returns vector three-velocities four-velocities.    stored three- four- column matrices; row velocity. Names inherited behaviour cbind(),   c().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"function used extensively   inst/distributive_search.R. “c” celerity speed light, see sol().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"","code":"c(r3vel(3),r3vel(6,0.99)) #> A vector of three-velocities (speed of light = 1) #>                x           y            z #>  [1,]  0.3142868  0.25798713 -0.070121648 #>  [2,] -0.4129981 -0.16240408  0.255299746 #>  [3,]  0.5359088 -0.30762813 -0.009353154 #>  [4,]  0.2138079 -0.07152971 -0.963986354 #>  [5,]  0.5646353  0.59005403  0.559574105 #>  [6,]  0.4053587 -0.65408832  0.622858539 #>  [7,] -0.1013869 -0.36781761 -0.913526624 #>  [8,] -0.2453738  0.66210526  0.693908003 #>  [9,] -0.1489798 -0.96745334 -0.148118401"},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":null,"dir":"Reference","previous_headings":"","what":"Celerity and rapidity — celerity","title":"Celerity and rapidity — celerity","text":"celerity rapidity object (experimental functionality)","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Celerity and rapidity — celerity","text":"","code":"# S3 method for 3vel celerity(u) # S3 method for 4vel celerity(u) celerity_ur(d) # S3 method for 3vel rapidity(u) # S3 method for 4vel rapidity(u) rapidity_ur(d) as.3cel(x) cel_to_vel(x) vel_to_cel(x)"},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Celerity and rapidity — celerity","text":"u,x Speed: either vector speeds vector     three-velocities four-velocities d functions celerity_ur() rapidity_ur(),       deficit speed; speed light minus speed object","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Celerity and rapidity — celerity","text":"celerity corresponding speed \\(u\\) defined   \\(u\\gamma\\) rapidity   \\(c\\cdot\\mathrm{atanh}(u/c)\\). Functions celerity_ur() rapidity_ur() used   ultrarelativistic case speeds close speed   light.  argument d deficit, , \\(d=c-v\\)   \\(v\\) speed transformation.  Algebraically,   celerity_ur(c-v) == celerity(v), \\(d=1-v/c\\) small   result celerity_ur() accurate   celerity(). Things get bit sticky celerity rapidity \\(c\\neq   1\\).  guiding principle package give   celerity rapidity units \\(c\\), \\(u\\ll   c\\) three celerity(u),   rapidity(u) u approximately equal.  Note   carefully , contrast, \\(\\gamma\\) dimensionless.  Also   observe d functions celerity_ur()   rapidity_ur() units \\(c\\).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Celerity and rapidity — celerity","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Celerity and rapidity — celerity","text":"","code":"u <- 0.1  # c=1 c(u,celerity(u),rapidity(u)) #> [1] 0.1000000 0.1005038 0.1003353  omgp <- 4.9e-24  # speed deficit of the Oh-My-God particle c(celerity_ur(omgp),rapidity_ur(omgp)) #> [1] 3.194383e+11 2.718298e+01   sol(299792458)                 # use SI units #> [1] 299792458 u <- 3e7  # ~0.1c c(u,celerity(u),rapidity(u)) #> [1] 30000000 30151345 30100745   snail <- 0.00275 c(snail,celerity(snail),rapidity(snail)) #> [1] 0.00275 0.00275 0.00275   omgp <- omgp*sol()  c(celerity_ur(omgp),rapidity_ur(omgp)) #> [1] 9.576519e+19 8.149252e+09   sol(1) #> [1] 1"},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":null,"dir":"Reference","previous_headings":"","what":"Failure of commutativity and associativity using visual plots — comm_fail","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"Relativistic addition three-velocities neither commutative associative, functions documented show visually.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"","code":"comm_fail1(u, v, bold=5, r=1) comm_fail2(u, v, bold=5, r=1) ass_fail(u, v, w, bold=5,r=1) my_seg(u,start=as.3vel(0), bold=5, ...)"},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"u,v,w,start Three velocities.  Arguments u w     single-element three velocities, argument v vector.  See     examples bold Integer specifying vector element drawn     bold r Radius dotted green circle, defaulting 1 (corresponding     \\(c=1\\)).  Use NA suppress plotting circle ... arguments, passed arrows()","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"functions called side-effect plotting diagram.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"vignette lorentz gives details   interpretation diagrams. Function my_seg() internal helper function.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"","code":"u <- as.3vel(c(0.4,0,0)) v <- seq(as.3vel(c(0.4,-0.2,0)), as.3vel(c(-0.3,0.9,0)),len=20) w <- as.3vel(c(0.8,-0.4,0))  comm_fail1(u=u, v=v)  comm_fail2(u=u, v=v)    ass_fail(u=u, v=v, w=w, bold=10)"},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Coordinate names for relativity — coordnames","title":"Coordinate names for relativity — coordnames","text":"Trivial function set coordinate names “t”, “x”, “y”, “z”.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coordinate names for relativity — coordnames","text":"","code":"coordnames(...) flob(x)"},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coordinate names for relativity — coordnames","text":"... arguments, currently ignored x matrix","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coordinate names for relativity — coordnames","text":"Function coordnames() simply returns character string   c(\"t\",\"x\",\"y\",\"z\").  may overwritten.   Function flob() sets row columnnames \\(4\\times     4\\) matrix coordnames().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coordinate names for relativity — coordnames","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Coordinate names for relativity — coordnames","text":"anyone can think better name flob() let know.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coordinate names for relativity — coordnames","text":"","code":"coordnames() #> [1] \"t\" \"x\" \"y\" \"z\"  flob(diag(3)) #>   x y z #> x 1 0 0 #> y 0 1 0 #> z 0 0 1 flob(matrix(1,4,4)) #>   t x y z #> t 1 1 1 1 #> x 1 1 1 1 #> y 1 1 1 1 #> z 1 1 1 1  ## You can change the names if you wish: coordnames <- function(x){letters[1:4]} flob(outer(1:4,1:4)) #>   t x  y  z #> t 1 2  3  4 #> x 2 4  6  8 #> y 3 6  9 12 #> z 4 8 12 16"},{"path":"https://robinhankin.github.io/lorentz/reference/cosines.html","id":null,"dir":"Reference","previous_headings":"","what":"Direction cosines — cosines","title":"Direction cosines — cosines","text":"Given vector three-velocities, returns direction cosines","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/cosines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Direction cosines — cosines","text":"","code":"cosines(u, drop = TRUE)"},{"path":"https://robinhankin.github.io/lorentz/reference/cosines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Direction cosines — cosines","text":"u vector three-velocities drop Boolean, default TRUE meaning coerce return     value one-row matrix vector, FALSE meaning     consistently return matrix","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/cosines.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Direction cosines — cosines","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/cosines.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Direction cosines — cosines","text":"","code":"cosines(r3vel(7)) #>                x           y           z #> [1,]  0.16248763  0.70775111  0.68752174 #> [2,] -0.79306771  0.45324734 -0.40695264 #> [3,] -0.20142245  0.62344671 -0.75547547 #> [4,] -0.77033336 -0.07327643  0.63341699 #> [5,]  0.95422046  0.11954321  0.27417646 #> [6,]  0.98655447 -0.14418291  0.07695169 #> [7,] -0.08212996 -0.28838475  0.95398580   cosines(r3vel(1),drop=TRUE) #>          x          y          z  #>  0.7458771  0.5997129 -0.2898480  cosines(r3vel(1),drop=FALSE) #>              x       y          z #> [1,] 0.8309629 0.55413 -0.0494018"},{"path":"https://robinhankin.github.io/lorentz/reference/galileo.html","id":null,"dir":"Reference","previous_headings":"","what":"Classical mechanics; Newtonian approximation; infinite speed of light — galileo","title":"Classical mechanics; Newtonian approximation; infinite speed of light — galileo","text":"Lorentz transforms reduce classical limit, Galilean transforms, speeds low compared \\(c\\).  Package idiom working classical framework use infinite speed light: sol(Inf).  show examples .","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/galileo.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Classical mechanics; Newtonian approximation; infinite speed of light — galileo","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/galileo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classical mechanics; Newtonian approximation; infinite speed of light — galileo","text":"","code":"sol(Inf) #> [1] Inf boost(as.3vel(1:3)) #>    t x y z #> t  1 0 0 0 #> x -1 1 0 0 #> y -2 0 1 0 #> z -3 0 0 1 as.3vel(1:3) + as.3vel(c(-1,4,5))     # classical velocity addition #> A vector of three-velocities (speed of light = Inf) #>      x y z #> [1,] 0 6 8 rot(as.3vel(1:3),as.3vel(c(-4,5,2)))  # identity matrix #>   x y z #> x 1 0 0 #> y 0 1 0 #> z 0 0 1   B <- boost(as.3vel(1:3)) orthog(B) %*% pureboost(B)  # should be B #>       t x y z #> [1,]  1 0 0 0 #> [2,] -1 1 0 0 #> [3,] -2 0 1 0 #> [4,] -3 0 0 1  sol(1) #> [1] 1"},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Gamma correction — gam","title":"Gamma correction — gam","text":"Lorentz gamma correction term special relativity","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gamma correction — gam","text":"","code":"# S3 method for 3vel speed(u) # S3 method for 4vel speed(u) speedsquared(u) gam(u) gamm1(u) # S3 method for 3vel gam(u) # S3 method for 3cel gam(u) # S3 method for 4vel gam(u) # S3 method for 3vel gamm1(u) # S3 method for 4vel gamm1(u) gam_ur(d)"},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gamma correction — gam","text":"u Speed: either vector speeds vector     three-velocities four-velocities d function gam_ur(), deficit speed; speed light       minus speed object","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gamma correction — gam","text":"Function speed(u) returns speed 3vel object   4vel object. Function gam(u) returns Lorentz factor   $$\\frac{1}{\\sqrt{1-\\mathbf{u}\\cdot\\mathbf{u}/c^2}}$$ Function gamm1(u) returns Lorentz factor minus 1, useful   slow speeds larger accuracy needed (much like   expm1()); see R idiom, type “gamm1.3vel”   commandline.  Function gamm1() intended work   3vel objects speeds.  function take 4-velocity,   recommended accuracy lost (return   time component 4-velocity minus 1). Function gam_ur() used ultrarelativistic case   speeds close speed light (function named   “gamma, ultrarelativistic”).  argument d   deficit, , \\(c-v\\) \\(v\\) speed   transformation.  Algebraically, gam_ur(c-v) == gam(v),   d small compared c result accurate. Function speedsquared(u) returns square speed   3vel object.  Use avoid taking needless square root.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gamma correction — gam","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gamma correction — gam","text":"","code":"gam(seq(from=0,by=0.1,len=10)) #>  [1] 1.000000 1.005038 1.020621 1.048285 1.091089 1.154701 1.250000 1.400280 #>  [9] 1.666667 2.294157 gam(r3vel(6,0.7)) #> [1] 1.40028 1.40028 1.40028 1.40028 1.40028 1.40028   x <- as.3vel(c(0.1,0.4,0.5)) speed(x) #> [1] 0.6480741  gam(speed(x))  # works, but slow and inaccurate #> [1] 1.313064 gam(x)         # recommended: avoids needless coercion #> [1] 1.313064    ## Use SI units and deal with terrestrial speeds.  Use gamm1() for this. sol(299792458) #> [1] 299792458 sound <- 343 # speed of sound in SI gam(sound) #> [1] 1 gam(sound)-1   #> [1] 6.545875e-13 gamm1(sound)   # gamm1() gives much higher precision #> [1] 6.545108e-13  snail <- as.3vel(c(0.00275,0,0)) # even the world's fastest snail... gamm1(snail)                     # ...has only a small relativistic correction #> [1] 4.207208e-23   ## For the ultrarelativistic case of speeds very close to the speed of ## light, use gam_ur():  sol(1)           # revert to relativistic units #> [1] 1  gam(0.99) - gam_ur(0.01) # zero to numerical accuracy #> [1] -4.440892e-15  omgp <- 4.9e-24  # speed deficit of the Oh-My-God particle gam(1-omgp)      # numeric overflow #> [1] Inf gam_ur(omgp)     # large but finite #> [1] 319438282500"},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":null,"dir":"Reference","previous_headings":"","what":"Gyr function — gyr","title":"Gyr function — gyr","text":"Relativistic addition three velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gyr function — gyr","text":"","code":"gyr(u, v, x) gyr.a(u, v, x) gyrfun(u, v)"},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gyr function — gyr","text":"u,v,x Three-velocities, objects class 3vel","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gyr function — gyr","text":"Function  gyr(u,v,x) returns three-vector   \\(\\mathrm{gyr}[u,v]x\\). Function gyrfun(u,v) returns function returns   three-vector; see examples. speed light (1 default) used directly   functions; set sol().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gyr function — gyr","text":"Ungar 2006. “Thomas precession: kinematic   effect algebra Einstein's velocity addition law.  Comments   ‘Deriving relativistic momentum energy: II.     Three-dimensional case’”. European Journal Physics,   27:L17-L20. Sbitneva 2001. “Nonassociative geometry special relativity”. International Journal Theoretical Physics, volume 40, number 1,   pages 359--362","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gyr function — gyr","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Gyr function — gyr","text":"Function gyr() slightly faster gyr.(),   included pedagogical reasons. Function gyr() simply add3(neg3(add3(u,v)),add3(u,add3(v,x))) function gyr.() uses slower transparent   idiom -(u+v) + (u+(v+x))","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gyr function — gyr","text":"","code":"u <- r3vel(10) v <- r3vel(10) w <- r3vel(10)  x <- as.3vel(c(0.4,0.1,-0.5)) y <- as.3vel(c(0.1,0.2,-0.7)) z <- as.3vel(c(0.2,0.3,-0.1))   gyr(u,v,x)  # gyr[u,v]x #> A vector of three-velocities (speed of light = 1) #>               x           y          z #>  [1,] 0.2442879 0.337031774 -0.4967222 #>  [2,] 0.5570502 0.045193996 -0.3281045 #>  [3,] 0.6018117 0.057768190 -0.2334212 #>  [4,] 0.3740342 0.005033197 -0.5292193 #>  [5,] 0.3614446 0.212308492 -0.4942498 #>  [6,] 0.4182291 0.086199557 -0.4874977 #>  [7,] 0.3625619 0.149125791 -0.5160527 #>  [8,] 0.4720870 0.016134780 -0.4437043 #>  [9,] 0.3691145 0.048261155 -0.5304954 #> [10,] 0.2597791 0.233837941 -0.5457423  f <- gyrfun(u,v) g <- gyrfun(v,u)  f(x) #> A vector of three-velocities (speed of light = 1) #>               x           y          z #>  [1,] 0.2442879 0.337031774 -0.4967222 #>  [2,] 0.5570502 0.045193996 -0.3281045 #>  [3,] 0.6018117 0.057768190 -0.2334212 #>  [4,] 0.3740342 0.005033197 -0.5292193 #>  [5,] 0.3614446 0.212308492 -0.4942498 #>  [6,] 0.4182291 0.086199557 -0.4874977 #>  [7,] 0.3625619 0.149125791 -0.5160527 #>  [8,] 0.4720870 0.016134780 -0.4437043 #>  [9,] 0.3691145 0.048261155 -0.5304954 #> [10,] 0.2597791 0.233837941 -0.5457423 f(r3vel(10)) #> A vector of three-velocities (speed of light = 1) #>                 x            y           z #>  [1,]  0.54716671 -0.091260658  0.67133150 #>  [2,]  0.08413118  0.049868038  0.76652821 #>  [3,]  0.48967118 -0.239999469  0.71648499 #>  [4,]  0.30519155  0.475225100 -0.39343994 #>  [5,]  0.06264271  0.643056853  0.47941945 #>  [6,]  0.38357849 -0.330434733  0.59825603 #>  [7,] -0.51663266  0.778808869 -0.02895268 #>  [8,] -0.15468439 -0.169872750  0.53145929 #>  [9,]  0.32276885 -0.002690179 -0.25078060 #> [10,]  0.59487238  0.373100250  0.29222814  f(g(x)) - x              # zero, by eqn 9 #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,]  3.589083e-16 -2.213268e-16  1.650978e-15 #>  [2,]  1.895036e-14 -3.995846e-15  1.129365e-14 #>  [3,] -3.589083e-16  1.770614e-15 -1.148507e-15 #>  [4,] -2.631994e-16 -1.794542e-16  2.871266e-16 #>  [5,] -1.196361e-16 -2.255141e-15  7.178166e-17 #>  [6,] -1.674905e-16 -2.990903e-16 -2.871266e-16 #>  [7,] -1.315997e-15 -1.567233e-15  1.435633e-15 #>  [8,]  1.196361e-16 -3.708719e-16 -1.435633e-16 #>  [9,] -6.221077e-16 -3.947991e-16  2.871266e-16 #> [10,]  1.165256e-14 -6.777385e-15  7.226021e-15 g(f(x)) - x              # zero, by eqn 9 #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,]  1.339924e-15  1.010925e-15  2.177377e-15 #>  [2,] -1.076725e-14 -2.691812e-15  1.170041e-14 #>  [3,]  5.072571e-15  4.767499e-15 -2.895194e-15 #>  [4,]  2.392722e-16 -1.794542e-16 -3.828355e-16 #>  [5,] -1.315997e-15  9.271798e-16  1.746687e-15 #>  [6,]  1.076725e-15 -4.187264e-16  7.178166e-17 #>  [7,] -1.746687e-15 -1.752669e-15  7.178166e-16 #>  [8,] -1.674905e-16 -5.981805e-17 -1.435633e-16 #>  [9,] -7.656711e-16 -4.127446e-16  2.871266e-16 #> [10,] -2.655921e-15 -4.373896e-14  2.258730e-14 (x+y) - f(y+x)           # zero by eqn 10 #> A vector of three-velocities (speed of light = 1) #>                 x            y           z #>  [1,]  0.58246674 -0.457691528 -0.50611844 #>  [2,] -0.37647149  0.091666458 -0.34000725 #>  [3,] -0.39503607 -0.069356996 -0.66113000 #>  [4,]  0.41937383  0.246179687  0.10424735 #>  [5,]  0.46008697 -0.422720447 -0.16367700 #>  [6,]  0.25164965 -0.006043159  0.07964991 #>  [7,]  0.48702028 -0.155873366  0.03064145 #>  [8,] -0.01305597  0.261293354  0.01334423 #>  [9,]  0.41807087 -0.018673275  0.08508633 #> [10,]  0.68411817  0.059400023  0.01783186 (u+(v+w)) - ((u+v)+f(w)) # zero by eqn 11 #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,]  0.000000e+00  0.000000e+00  4.524772e-15 #>  [2,]  0.000000e+00  6.707404e-15  1.341481e-14 #>  [3,]  0.000000e+00 -3.513471e-15  1.756736e-15 #>  [4,]  0.000000e+00  0.000000e+00 -1.258274e-16 #>  [5,]  1.843746e-15 -1.474996e-14 -3.687491e-15 #>  [6,]  1.066582e-14  0.000000e+00 -5.332912e-15 #>  [7,]  0.000000e+00 -8.173305e-16  3.269322e-15 #>  [8,]  0.000000e+00  6.061784e-17  0.000000e+00 #>  [9,]  3.221881e-16  2.577505e-15  0.000000e+00 #> [10,] -2.236388e-14  5.590971e-15  0.000000e+00   # Following taken from Sbitneva 2001:  rbind(x+(y+(x+z))  ,   (x+(y+x))+z)   # left Bol property #>           [,1]      [,2]       [,3] #> [1,] 0.4894115 0.2314344 -0.8300767 #> [2,] 0.4894115 0.2314344 -0.8300767 rbind((x+y)+(x+y)  ,   x+(y+(y+x)))   # left Bruck property #>          [,1]     [,2]       [,3] #> [1,] 0.432766 0.209512 -0.8738679 #> [2,] 0.432766 0.209512 -0.8738679   sol(299792458)   # speed of light in SI #> [1] 299792458 as.3vel(c(1000,3000,1000)) + as.3vel(c(1000,3000,1000)) #> A vector of three-velocities (speed of light = 299792458) #>         x    y    z #> [1,] 2000 6000 2000 ## should be close to Galilean result  sol(1)   # revert to default c=1 #> [1] 1"},{"path":"https://robinhankin.github.io/lorentz/reference/lorentz-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The Lorentz Transform in Relativistic Physics — lorentz-package","title":"The Lorentz Transform in Relativistic Physics — lorentz-package","text":"Lorentz transform special relativity; also     gyrogroup structure three-velocities.  Performs active     passive transforms ability use units     speed light unity.  Includes experimental     functionality celerity rapidity.  general relativity,     see 'schwarzschild' package.  cite lorentz package     publications please use Hankin (2022)     <doi:10.48550/ARXIV.2212.07005>.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/lorentz-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Lorentz Transform in Relativistic Physics — lorentz-package","text":"DESCRIPTION file: package yet installed build time.   Index:  package yet installed build time.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/lorentz-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The Lorentz Transform in Relativistic Physics — lorentz-package","text":"NA Maintainer: Robin K. S. Hankin <hankin.robin@gmail.com>","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/lorentz-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Lorentz Transform in Relativistic Physics — lorentz-package","text":"Ungar 2006. “Thomas precession: kinematic   effect...”. European Journal Physics, 27:L17-L20. https://www.youtube.com/watch?v=9Y9CxiukURw&index=68&list=PL9_n3Tqzq9iWtgD8POJFdnVUCZ_zw6OiB","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/lorentz-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Lorentz Transform in Relativistic Physics — lorentz-package","text":"","code":"u <- as.3vel(c(0.3,0.6,-0.1))  # u is a three-velocity gam(u)                         # relativistic gamma term for u #> [1] 1.360828 U <- as.4vel(u)                # U is a four-velocity B1 <- boost(u)                 # B1 is the Lorentz transform matrix for u B1 %*% c(1,0,0,0)              # Lorentz transform of zero 4-velocity (=-u) #>         [,1] #> t  1.3608276 #> x -0.4082483 #> y -0.8164966 #> z  0.1360828  B2 <- boost(as.3vel(c(-0.1,0.8,0.3)))   B3 <- boost(as.3vel(c(-0.1,0.1,0.9)))  # more boosts  Bi <- B1 %*% B2  # Bi is the boost for successive Lorentz transforms   pureboost(Bi)      # Decompose Bi into a pure boost... #>             t           x           y           z #> t  3.78969964 -0.06713162 -3.54542995 -0.88726725 #> x -0.06713162  1.00094091  0.04969215  0.01243579 #> y -3.54542995  0.04969215  3.62439704  0.65677268 #> z -0.88726725  0.01243579  0.65677268  1.16436170 orthog(Bi)         # and an orthogonal matrix #>               t             x             y             z #> t  1.000000e+00 -1.041767e-14 -5.394647e-13 -1.348189e-13 #> x -1.246934e-13  9.794943e-01  1.895365e-01  6.831470e-02 #> y -5.534047e-13 -1.983854e-01  9.664761e-01  1.629943e-01 #> z -3.920328e-14 -3.513115e-02 -1.732047e-01  9.842591e-01  Bj <- B2 %*% B1    # B1 and B2 do not commute...  (B1 %*% B2) %*% B3  #>            t          x          y          z #> t  11.971728  1.0488714 -4.6614329 -10.931294 #> x  -2.357261  0.7672474  1.0039324   2.227135 #> y -11.332721 -1.2028617  4.6544280  10.311158 #> z  -2.887046 -0.2541382  0.2395334   3.035305 B1 %*% (B2 %*% B3)    # ...but composition *is* associative #>            t          x          y          z #> t  11.971728  1.0488714 -4.6614329 -10.931294 #> x  -2.357261  0.7672474  1.0039324   2.227135 #> y -11.332721 -1.2028617  4.6544280  10.311158 #> z  -2.887046 -0.2541382  0.2395334   3.035305    ## Three velocities and the gyrogroup  ## Create some random three-velocities:  u <- r3vel(10) v <- r3vel(10) w <- r3vel(10)  u+v #> A vector of three-velocities (speed of light = 1) #>                 x          y           z #>  [1,] -0.20408739 -0.7977508 -0.15196867 #>  [2,] -0.97007181 -0.1066702  0.06497122 #>  [3,] -0.50323209  0.4862910 -0.67011257 #>  [4,] -0.09099542 -0.2318888 -0.22043203 #>  [5,]  0.34595563  0.7481107 -0.54892421 #>  [6,]  0.12237488 -0.8207788 -0.55772997 #>  [7,] -0.44336350 -0.7512256  0.48743807 #>  [8,] -0.07129075 -0.2130210  0.70673828 #>  [9,] -0.73649524  0.1279826  0.61412953 #> [10,] -0.86146638  0.4522019 -0.21516407 v+u        # Three-velocity addition is not commutative... #> A vector of three-velocities (speed of light = 1) #>                 x           y          z #>  [1,] -0.15578415 -0.80427487  0.1732791 #>  [2,] -0.86858876  0.04352992  0.4475465 #>  [3,]  0.21965911  0.12117504 -0.9358626 #>  [4,] -0.08982864 -0.24500161 -0.2062714 #>  [5,]  0.03910543  0.81979619  0.5541459 #>  [6,]  0.73407024 -0.60781813 -0.3023477 #>  [7,] -0.67620994 -0.62029006  0.3955847 #>  [8,]  0.11141824 -0.12114752  0.7230827 #>  [9,] -0.62363396 -0.35635530  0.6481137 #> [10,] -0.55870023  0.11818825 -0.8165734  u+(v+w)   # ... nor associative #> A vector of three-velocities (speed of light = 1) #>                x           y           z #>  [1,] -0.2669301 -0.93233627 -0.01641218 #>  [2,] -0.9944552  0.02336731  0.08221263 #>  [3,] -0.5719218  0.36535712 -0.73008809 #>  [4,] -0.1863224 -0.65579885  0.45310904 #>  [5,]  0.4725820  0.50425337 -0.71127856 #>  [6,]  0.1128928 -0.82065582 -0.56009511 #>  [7,] -0.4506900 -0.74940196  0.48468337 #>  [8,] -0.3575769 -0.03923267  0.91309179 #>  [9,] -0.7770161  0.11456971  0.60317120 #> [10,] -0.8532624  0.46961469 -0.22375827 (u+v)+w  #> A vector of three-velocities (speed of light = 1) #>                x           y           z #>  [1,] -0.2555283 -0.92243668  0.08913475 #>  [2,] -0.9907026  0.05243089  0.10324417 #>  [3,] -0.5425429  0.32228534 -0.76977186 #>  [4,] -0.1766308 -0.62639285  0.48569110 #>  [5,]  0.3810550  0.68789099 -0.61712345 #>  [6,]  0.1186516 -0.82066961 -0.55891143 #>  [7,] -0.4546464 -0.74778812  0.48342003 #>  [8,] -0.2850752 -0.01906965  0.94003956 #>  [9,] -0.7749536  0.06936770  0.61049854 #> [10,] -0.8489554  0.46467356 -0.24810513"},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":null,"dir":"Reference","previous_headings":"","what":"Photons — photon","title":"Photons — photon","text":"Various functionality deal 4-momentum photon","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Photons — photon","text":"","code":"is.consistent.nullvec(N,TOL=1e-10) as.photon(x,E=1)"},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Photons — photon","text":"N Four-momentum tested nullness TOL tolerance x Vector three-velocities E Energy, scalar","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Photons — photon","text":"Returns four-momentum photon.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Photons — photon","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Photons — photon","text":"","code":"## A bunch of photons all approximately parallel to the x-axis: as.photon(as.3vel(cbind(0.9,runif(10)/1000,runif(10)/1000))) #>       E       p_x          p_y          p_z #>  [1,] 1 0.9999998 4.677821e-05 0.0005498368 #>  [2,] 1 0.9999999 4.902157e-04 0.0000477413 #>  [3,] 1 0.9999988 1.111087e-03 0.0010386645 #>  [4,] 1 0.9999995 6.285776e-04 0.0007471418 #>  [5,] 1 0.9999997 3.874720e-04 0.0006999622 #>  [6,] 1 0.9999997 5.462313e-04 0.0005358577 #>  [7,] 1 0.9999990 9.446404e-04 0.0010381763 #>  [8,] 1 0.9999996 8.060270e-04 0.0002913104 #>  [9,] 1 0.9999999 8.860516e-05 0.0003930186 #> [10,] 1 0.9999999 3.769906e-04 0.0002155767   ## mirror ball: jj <- matrix(rnorm(30),10,3) disco <- sweep(matrix(rnorm(30),10,3),1,sqrt(rowSums(jj^2)),`/`) p <- as.photon(c(1,0,0)) reflect(p,disco) #>   E          p_x         p_y          p_z #> x 1  0.590570942 -0.62265539 -0.513348056 #> x 1  0.007430552  0.45661924 -0.889631189 #> x 1  0.714695019 -0.40555965  0.569852961 #> x 1 -0.529364803 -0.80270667 -0.274654154 #> x 1  0.426332320 -0.86176572 -0.274955614 #> x 1  0.997708567  0.05653437 -0.037168291 #> x 1  0.985043236  0.13941961 -0.101252140 #> x 1  0.993246295 -0.11593266  0.004627756 #> x 1 -0.380859156 -0.42950636  0.818822684 #> x 1  0.868065322 -0.44405485  0.221986232  table(reflect(p,disco)[,2]>0) # should be TRUE with probability sqrt(0.5) #>  #> FALSE  TRUE  #>     2     8   ## relativistic  disco; mirror ball moves at 0.5c:  B <- boost(as.3vel(c(0.5,0,0))) p |> tcrossprod(B) |> reflect(disco) |> tcrossprod(solve(B)) #>           t           x           y            z #> x 0.8635236  0.72704729 -0.35949026 -0.296381639 #> x 0.6691435  0.33828703  0.26362924 -0.513628807 #> x 0.9048983  0.80979668 -0.23414997  0.329004761 #> x 0.4902117 -0.01957654 -0.46344291 -0.158571650 #> x 0.8087774  0.61755488 -0.49754067 -0.158745697 #> x 0.9992362  0.99847238  0.03264013 -0.021459123 #> x 0.9950144  0.99002882  0.08049395 -0.058457950 #> x 0.9977488  0.99549753 -0.06693375  0.002671836 #> x 0.5397136  0.07942723 -0.24797561  0.472747497 #> x 0.9560218  0.91204355 -0.25637519  0.128163811"},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print methods for three-velocities and four-velocities — print.3vel","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"Print methods three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"","code":"# S3 method for 3vel print(x, ...) # S3 method for 3cel print(x, ...) # S3 method for 4vel print(x, ...) # S3 method for 4mom print(x, ...)"},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"x Vector three-velocities ... arguments, currently ignored","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"Returns vector three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"","code":"r3vel(10) #> A vector of three-velocities (speed of light = 1) #>                x           y           z #>  [1,]  0.2614368  0.67891194 -0.47094219 #>  [2,] -0.7795073  0.55609119 -0.09823764 #>  [3,] -0.5995605 -0.00639958  0.14477206 #>  [4,] -0.4613698 -0.53042109 -0.27941292 #>  [5,]  0.7172186  0.19669978 -0.59089280 #>  [6,] -0.1030614  0.03894058  0.91429095 #>  [7,] -0.2481978 -0.22963965 -0.25229363 #>  [8,] -0.4206152 -0.81730142 -0.02141212 #>  [9,] -0.7275229 -0.27440648  0.61450421 #> [10,] -0.2534993  0.56443184 -0.78030443"},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":null,"dir":"Reference","previous_headings":"","what":"Random relativstic velocities — r3vel","title":"Random relativstic velocities — r3vel","text":"Generates random three-velocities four-velocities, optionally specifiying magnitude","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random relativstic velocities — r3vel","text":"","code":"r3vel(n=7, r = NA) r4vel(...) rboost(r = NA)"},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random relativstic velocities — r3vel","text":"n Number three- four- velocities generate r Absolute value three-velocities, default     NA meaning sample uniformly unit ball ... Arguments passed r3vel()","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random relativstic velocities — r3vel","text":"Function r3vel() returns random three-velocity.  Function   r4vel() convenience wrapper .4vel(r3vel()). Function rboost() returns random \\(4\\times 4\\) Lorentz   boost matrix, drawn connected component.  given   r=0, transform corresponding random rotation   returned.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random relativstic velocities — r3vel","text":"Returns vector three- four- velocities.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random relativstic velocities — r3vel","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Random relativstic velocities — r3vel","text":"speed light infinite, functions require specified   argument r. entirely trivial sample uniformly unit ball   unit sphere, hard either.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random relativstic velocities — r3vel","text":"","code":"r3vel() #> A vector of three-velocities (speed of light = 1) #>                x          y           z #> [1,]  0.14192112  0.6859066 -0.67028970 #> [2,] -0.30999663 -0.8598434  0.21029168 #> [3,] -0.01375558 -0.6526175  0.02532186 #> [4,]  0.48134043 -0.4408335 -0.40524772 #> [5,] -0.51415273 -0.1799992 -0.09286733 #> [6,]  0.84757962  0.3069914 -0.15663288 #> [7,] -0.05993228 -0.9102120  0.27472245  a <- r3vel(10000) b <- r3vel(1000,0.8) u <- as.3vel(c(0,0,0.9))  pairs(unclass(u+a),asp=1)  pairs(unclass(a+u),asp=1)   is.consistent.boost(rboost()) #> [1] TRUE  sol(299792458)    # switch to SI units #> [1] 299792458 sound <- 343      # speed of sound in metres per second r3vel(100,343)    # random 3-velocities with speed = 343 m/s #> A vector of three-velocities (speed of light = 299792458) #>                  x            y            z #>   [1,] -183.520578  -62.7740310 -282.8932990 #>   [2,]   54.701335  336.4278777  -38.3802947 #>   [3,]   27.181983 -280.0396053 -196.1834836 #>   [4,]   22.788859   36.1793501 -340.3244372 #>   [5,] -209.097219 -271.8958456    0.0465768 #>   [6,]   37.741428 -195.4610189 -279.3198430 #>   [7,]  267.907633 -167.9086919 -132.9705665 #>   [8,]  -90.432215 -329.4613888   30.4336617 #>   [9,]  104.003569  307.6910591  110.2654516 #>  [10,] -324.393906   65.7958559  -89.9360831 #>  [11,] -106.427114  126.8445957  300.3876129 #>  [12,]  104.365234    3.2075651  326.7209964 #>  [13,] -155.942824  259.4026833 -161.3724995 #>  [14,]  100.631271 -230.6242785 -233.0982398 #>  [15,]  -15.922261  289.2762146 -183.6157762 #>  [16,]  187.242458 -284.3103170  -41.9154571 #>  [17,]  139.113380  181.5351629 -255.6197414 #>  [18,]  332.220649   33.8917048   78.2929911 #>  [19,]  -12.942638   79.6247910  333.3787347 #>  [20,]  -18.879600  131.2934150 -316.3140842 #>  [21,]  149.410548  305.7396851  -42.9968968 #>  [22,] -225.208586  115.7246666 -231.3825710 #>  [23,]  117.469258  243.9066009 -210.6170543 #>  [24,]  277.517826 -166.3270926 -113.8778045 #>  [25,]   -1.117874  337.3775647  -61.8395438 #>  [26,]  -23.368605   82.0856713 -332.2120571 #>  [27,]  313.930517 -107.2550442   87.1377429 #>  [28,] -250.885642 -120.3522021 -200.5510958 #>  [29,]  101.001801 -211.4842889 -250.4436700 #>  [30,]  194.125175  280.4343883  -36.3451546 #>  [31,] -305.721303   47.3322710  148.1321736 #>  [32,]  100.501272  226.6588963  237.0110525 #>  [33,] -136.871425 -278.6910117 -145.7619048 #>  [34,] -248.223287 -226.5861129  -68.5049862 #>  [35,] -306.271685  -18.8261806 -153.2717519 #>  [36,] -201.459940 -142.0158187  238.5254703 #>  [37,] -278.592349 -129.6980565 -152.3604846 #>  [38,]  112.238885 -125.0831995 -299.0077355 #>  [39,] -148.064918 -268.5361637 -153.6688283 #>  [40,]   35.569423 -327.1441799   96.7496858 #>  [41,]  241.031374  165.1352092  179.6753720 #>  [42,] -116.461141 -302.5476976 -112.0298773 #>  [43,]   -3.945222  -87.2265486 -331.7001122 #>  [44,] -213.542563   89.6861373  252.9920365 #>  [45,]  307.361455 -130.4898402   78.4240887 #>  [46,] -174.872674 -210.6003465 -206.6785959 #>  [47,]  155.003286  280.0283681 -123.3170486 #>  [48,]  -88.737470   80.1590676 -321.4796809 #>  [49,]   13.236984 -262.2115625  220.7235346 #>  [50,]  218.327382  197.1407379  176.4020509 #>  [51,]  130.721472  250.2268230 -194.8010107 #>  [52,]  199.428476 -214.3999911 -178.6334990 #>  [53,] -257.394544  -86.0063842  209.7616514 #>  [54,]  294.075925  -48.4442273  169.7689815 #>  [55,]  284.675882  158.8660834 -106.6311855 #>  [56,]  206.338653  -92.5006834 -257.9088675 #>  [57,] -116.032131 -217.0024193 -238.9466357 #>  [58,]  328.121024  -88.0706494   47.2139206 #>  [59,]  247.323364  -84.4256560  222.1541403 #>  [60,] -207.915272  224.5494875 -154.9121273 #>  [61,]  -44.945630 -333.3009852   67.3746510 #>  [62,]  125.018850 -294.0526746 -124.7089080 #>  [63,]  215.822032 -259.0739715  -62.8532259 #>  [64,] -153.775005  215.6632448  217.9257044 #>  [65,]   41.745605 -291.8533249 -175.2938710 #>  [66,]   -7.738249  288.5552997 -185.2699612 #>  [67,] -235.162189   66.8410090 -240.5826772 #>  [68,]  -68.191477 -335.9830143   10.6928248 #>  [69,] -107.325738 -222.5769449 -237.8858752 #>  [70,]   47.874307  262.9595639 -214.9635283 #>  [71,]   -3.787483  276.6170308  202.7749325 #>  [72,]  -42.588392   -0.3608005  340.3455578 #>  [73,]  234.526961 -194.6710538  157.3190554 #>  [74,] -206.932640 -271.1753556   35.9417465 #>  [75,]   13.353079  329.0610961   95.8618291 #>  [76,]  -16.564762 -111.4548042  323.9636326 #>  [77,]  221.978941 -260.9062300  -17.3864568 #>  [78,] -272.780008 -205.2040941   33.6355031 #>  [79,] -287.640529  127.5326587 -136.5552899 #>  [80,] -177.179200 -284.7385008  -71.9758104 #>  [81,] -292.481010 -167.9864226   62.3251192 #>  [82,]   41.077417   17.7708884 -340.0674071 #>  [83,]   37.156348  198.5837071  277.1875124 #>  [84,]  -79.750185 -174.8852569  284.0845912 #>  [85,]  258.911482  -89.7601711  206.2933739 #>  [86,] -168.308378 -209.0252390  213.6111869 #>  [87,]  269.251390  177.2205632 -117.2414651 #>  [88,]  -57.321713 -106.0786851  321.1082898 #>  [89,]    8.780860  -90.9480896  330.6060216 #>  [90,]  212.206522 -219.3956809 -156.4702117 #>  [91,]   26.070852 -285.4018734  188.4544543 #>  [92,]   52.756738 -141.5749419 -307.9322367 #>  [93,]  128.329997  -79.5771889  307.9738346 #>  [94,] -324.047888  -26.9896841  109.1490878 #>  [95,] -341.393731  -32.9230346   -3.9235059 #>  [96,] -186.211973  286.7819681  -27.0222839 #>  [97,]    8.012523  143.1478525 -311.5982859 #>  [98,]  314.886559  126.8544253  -49.0245810 #>  [99,] -238.051511 -223.9052971  104.1484327 #> [100,]  289.050569  164.1580405   84.5630324  sol(1)   # return to default c=1 #> [1] 1"},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":null,"dir":"Reference","previous_headings":"","what":"Mirrors — reflect","title":"Mirrors — reflect","text":"Plane mirrors special relativity","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mirrors — reflect","text":"","code":"reflect(P,m,ref=1)"},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mirrors — reflect","text":"P Vector four-momenta m Orientation mirror, expressed three-vector ref Coefficient reflectivity mirror","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mirrors — reflect","text":"Takes four-momentum returns four-momentum reflection.   handle objects photons.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mirrors — reflect","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Mirrors — reflect","text":"four-momenta measured rest frame mirror,   easy reflect moving mirrors; see examples. However, note ref argument designed work   photons , conceptually percentage photons   reflected absorbed mirror.  ref less   unity, odd results given four momenta nonzero restmass   objects.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mirrors — reflect","text":"","code":"## We will reflect some photons from an oblique mirror moving at half ## the speed of light.  ## First create 'A', a bunch of photons all moving roughly along the x-axis: A <- as.photon(as.3vel(cbind(0.9,runif(10)/1000,runif(10)/1000)))  ## Now create 'm', a mirror oriented perpendicular to c(1,1,1): m <- c(1,1,1)  ## Reflect the photons in the mirror: reflect(A,m) #>       E       p_x        p_y        p_z #>  [1,] 1 0.3324516 -0.6670799 -0.6666936 #>  [2,] 1 0.3325774 -0.6669998 -0.6667110 #>  [3,] 1 0.3329458 -0.6669184 -0.6666085 #>  [4,] 1 0.3325449 -0.6672908 -0.6664360 #>  [5,] 1 0.3322768 -0.6666230 -0.6672376 #>  [6,] 1 0.3327513 -0.6666412 -0.6669828 #>  [7,] 1 0.3331834 -0.6666631 -0.6667451 #>  [8,] 1 0.3326996 -0.6664034 -0.6672462 #>  [9,] 1 0.3323427 -0.6667227 -0.6671050 #> [10,] 1 0.3321336 -0.6671476 -0.6667844  ## Reflect the photons in a series of mirrors: A |> reflect(m) |> reflect(1:3) |> reflect(3:1)  #>       E        p_x        p_y       p_z #>  [1,] 1 -0.6464806 -0.7479320 0.1505343 #>  [2,] 1 -0.6464679 -0.7479719 0.1503901 #>  [3,] 1 -0.6462933 -0.7481794 0.1501086 #>  [4,] 1 -0.6462283 -0.7481216 0.1506756 #>  [5,] 1 -0.6470082 -0.7475403 0.1502129 #>  [6,] 1 -0.6466730 -0.7478804 0.1499632 #>  [7,] 1 -0.6463626 -0.7481932 0.1497407 #>  [8,] 1 -0.6469211 -0.7477037 0.1497738 #>  [9,] 1 -0.6468745 -0.7476450 0.1502675 #> [10,] 1 -0.6466334 -0.7477513 0.1507751   ## To reflect from a moving mirror we need to transform to a frame in ## which the mirror is at rest, then transform back to the original ## frame.  First create B, a boost representing the mirror's movement ## along the x-axis at speed c/2:  B <- boost(as.3vel(c(0.5,0,0)))   ## Transform to the mirror's rest frame: A %*% t(B)     #>               t         x            y            z #>  [1,] 0.5773505 0.5773497 0.0004680413 8.542768e-04 #>  [2,] 0.5773505 0.5773499 0.0004224291 7.112701e-04 #>  [3,] 0.5773503 0.5773501 0.0001357076 4.455753e-04 #>  [4,] 0.5773506 0.5773497 0.0001637773 1.018554e-03 #>  [5,] 0.5773507 0.5773494 0.0010995267 4.849439e-04 #>  [6,] 0.5773504 0.5773500 0.0006072789 2.656231e-04 #>  [7,] 0.5773503 0.5773503 0.0001534039 7.141823e-05 #>  [8,] 0.5773505 0.5773498 0.0008965774 5.378331e-05 #>  [9,] 0.5773506 0.5773496 0.0009339852 5.516620e-04 #> [10,] 0.5773508 0.5773493 0.0007180230 1.081215e-03  ## NB: in the above, take a transpose because the *rows* of A are 4-vectors.  ## Then reflect the photons in the mirror: reflect(A %*% t(B),m) #>               E       p_x        p_y        p_z #>  [1,] 0.5773505 0.1915684 -0.3853133 -0.3849271 #>  [2,] 0.5773505 0.1916942 -0.3852333 -0.3849444 #>  [3,] 0.5773503 0.1920625 -0.3851519 -0.3848420 #>  [4,] 0.5773506 0.1916617 -0.3855242 -0.3846694 #>  [5,] 0.5773507 0.1913935 -0.3848564 -0.3854710 #>  [6,] 0.5773504 0.1918681 -0.3848747 -0.3852163 #>  [7,] 0.5773503 0.1923002 -0.3848966 -0.3849786 #>  [8,] 0.5773505 0.1918164 -0.3846369 -0.3854797 #>  [9,] 0.5773506 0.1914594 -0.3849562 -0.3853385 #> [10,] 0.5773508 0.1912503 -0.3853810 -0.3850178   ## Now transform back to the original rest frame (NB: active transform): A |> tcrossprod(B) |> reflect(m) |> tcrossprod(solve(B)) #>               t         x          y          z #>  [1,] 0.7772690 0.5545376 -0.3853133 -0.3849271 #>  [2,] 0.7773416 0.5546828 -0.3852333 -0.3849444 #>  [3,] 0.7775541 0.5551081 -0.3851519 -0.3848420 #>  [4,] 0.7773229 0.5546453 -0.3855242 -0.3846694 #>  [5,] 0.7771682 0.5543357 -0.3848564 -0.3854710 #>  [6,] 0.7774419 0.5548836 -0.3848747 -0.3852163 #>  [7,] 0.7776913 0.5553825 -0.3848966 -0.3849786 #>  [8,] 0.7774122 0.5548239 -0.3846369 -0.3854797 #>  [9,] 0.7772062 0.5544118 -0.3849562 -0.3853385 #> [10,] 0.7770856 0.5541704 -0.3853810 -0.3850178"},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":null,"dir":"Reference","previous_headings":"","what":"seq method for three velocities — seq.3vel","title":"seq method for three velocities — seq.3vel","text":"Simplified version seq() three-velocities.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"seq method for three velocities — seq.3vel","text":"","code":"# S3 method for 3vel seq(from, to, len, ...)"},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"seq method for three velocities — seq.3vel","text":",Start end sequence len Length vector returned ... arguments (currently ignored)","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"seq method for three velocities — seq.3vel","text":"seq(,b,n) returns + t*(-b+) t   numeric vector seq(=0,=1,len=n). definition one several plausible alternatives,   nice property first last elements exactly equal   b respectively.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"seq method for three velocities — seq.3vel","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"seq method for three velocities — seq.3vel","text":"","code":"a <- as.3vel(c(4,5,6)/9) b <- as.3vel(c(-5,6,8)/14) x <- seq(a,b,len=9)  x[1]-a # should be zero #> A vector of three-velocities (speed of light = 1) #>      x y z #> [1,] 0 0 0 x[9]-b # should be zero #> A vector of three-velocities (speed of light = 1) #>                x             y             z #> [1,] 2.22201e-15 -8.428313e-16 -1.072694e-15   jj <- a + seq(0,1,len=9)*(b-a)  jj-x   # decidedly non-zero #> A vector of three-velocities (speed of light = 1) #>                 x         y         z #>  [1,]  0.00000000 0.0000000 0.0000000 #>  [2,] -0.04838804 0.1181117 0.1533975 #>  [3,] -0.03232101 0.2418630 0.3086692 #>  [4,]  0.03217792 0.3559577 0.4477686 #>  [5,]  0.11675360 0.4488587 0.5584128 #>  [6,]  0.19150356 0.5159410 0.6371904 #>  [7,]  0.23782735 0.5594566 0.6884694 #>  [8,]  0.25335939 0.5854552 0.7200976 #>  [9,]  0.24656019 0.6002548 0.7393787"},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":null,"dir":"Reference","previous_headings":"","what":"The energy-momentum tensor — transform","title":"The energy-momentum tensor — transform","text":"Various functionality deal stress-energy tensor   special relativity.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The energy-momentum tensor — transform","text":"","code":"perfectfluid(rho,p,u=0) dust(rho,u=0) photongas(rho,u=0) transform_dd(TT, B) transform_ud(TT, B) transform_uu(TT, B) raise(TT) lower(TT)"},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The energy-momentum tensor — transform","text":"TT second-rank tensor indices either     downstairs-downstairs, downstairs-upstairs, upstairs-upstairs B boost matrix rho,p,u Density, pressure, four-velocity dust","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The energy-momentum tensor — transform","text":"Function perfectfluid() returns stress-energy tensor,   two upstairs indices, perfect fluid conditions   specified.  checking physical reasonableness (eg weak   energy condition) performed: caveat emptor! Function dust() (trivial) function returns   stress-energy tensor zero-pressure perfect fluid (, dust).   Function photongas() returns stress-energy tensor   photon gas.  discoverability reasons;   special cases perfect fluid. Functions transform_dd() et seq transform second-rank tensor   using Lorentz transform.  letters “u” “d”   denote indices tensor upstairs (contravariant)   downstairs (covariant).  stress-energy tensor usually written   two upstairs indices, use transform_uu() transform   . Function lower() lowers indices tensor two   upstairs indices.  Function raise() raises two downstairs   indices.  two functions identical R idiom return   identical values \\(c\\neq 1\\).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The energy-momentum tensor — transform","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The energy-momentum tensor — transform","text":"","code":"perfectfluid(10,1) #>    t x y z #> t 10 0 0 0 #> x  0 1 0 0 #> y  0 0 1 0 #> z  0 0 0 1  u <- as.3vel(c(0.4,0.4,0.2))  ## In the following, LHS is stationary dust and RHS is dust moving at ## velocity 'u', but transformed to a frame also moving at velocity 'u':  LHS <- dust(1) RHS <- transform_uu(dust(1,u),boost(u)) max(abs(LHS-RHS))  # should be small #> [1] 6.938894e-17   ## In the following, negative sign needed because active/passive ## difference:  LHS <- dust(1,u) RHS <- transform_uu(dust(1),boost(-u)) max(abs(LHS-RHS))  # should be small #> [1] 0  ## Now test behaviour when  c!=1:   sol(299792458) #> [1] 299792458 perfectfluid(1.225,101325) # air at STP #>       t            x            y            z #> t 1.225 0.000000e+00 0.000000e+00 0.000000e+00 #> x 0.000 1.127393e-12 0.000000e+00 0.000000e+00 #> y 0.000 0.000000e+00 1.127393e-12 0.000000e+00 #> z 0.000 0.000000e+00 0.000000e+00 1.127393e-12  LHS <- transform_uu(perfectfluid(1.225,101325),boost(as.3vel(c(1000,0,0)))) RHS <- perfectfluid(1.225,101325)  LHS-RHS  # should be small #>               t       x y z #> t  1.362999e-11   -1225 0 0 #> x -1.225000e+03 1225000 0 0 #> y  0.000000e+00       0 0 0 #> z  0.000000e+00       0 0 0  sol(10) #> [1] 10 u <- as.3vel(4:6) LHS <- photongas(1,u) RHS <- transform_uu(photongas(1),boost(-u)) LHS-RHS # should be small #>               t             x             y             z #> t -8.881784e-16 -3.552714e-15  3.552714e-15  0.000000e+00 #> x -3.552714e-15  0.000000e+00  1.421085e-14  0.000000e+00 #> y  3.552714e-15  1.421085e-14  1.421085e-14 -2.842171e-14 #> z  0.000000e+00  0.000000e+00 -2.842171e-14 -2.842171e-14    B1 <- boost(r3vel(1)) %*% boost(r3vel(1)) B2 <- boost(r3vel(1)) %*% boost(r3vel(1)) LHS <- transform_uu(transform_uu(dust(1),B1),B2) RHS <- transform_uu(dust(1),B2 %*% B1)   # note order LHS-RHS  # should be small #>               t             x y             z #> t -5.684342e-14  0.000000e+00 0 -4.547474e-13 #> x -4.547474e-13  0.000000e+00 0  0.000000e+00 #> y -4.547474e-13 -1.818989e-12 0  0.000000e+00 #> z -4.547474e-13  0.000000e+00 0 -3.637979e-12   ## remember to re-set c: sol(1) #> [1] 1"},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":null,"dir":"Reference","previous_headings":"","what":"Speed of light and Minkowski metric — sol","title":"Speed of light and Minkowski metric — sol","text":"Getting setting speed light","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Speed of light and Minkowski metric — sol","text":"","code":"sol(c) eta(downstairs=TRUE) ptm(to_natural=TRUE, change_time=TRUE)"},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Speed of light and Minkowski metric — sol","text":"c Scalar, speed light.  missing, return speed     light downstairs Boolean, default TRUE meaning return     covariant metric tensor \\(g_{ij}\\) two downstairs       indices, FALSE meaning return contravariant       version \\(g^{ij}\\) two upstairs indices to_natural,change_time Boolean, specifying       nature passive transform matrix","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Speed of light and Minkowski metric — sol","text":"context R package, symbol “c” presents   particular problems.  lorentz package, speed light   denoted “sol”, ‘speed light’.  can set   speed light sol(x), query sol(); see   examples.  infinite speed light sometimes useful   Galilean transforms. speed light global variable, governed   options(\"c\").  NULL, define c=1.  Setting   showSOL TRUE makes sol() change prompt   display speed light might useful. Function eta() returns Minkowski flat-space metric   $$\\mathrm{diag}\\left(-c^2,1,1,1\\right).$$ Note top-left element eta() \\(-c^2\\),   \\(-1\\). Function ptm() returns passive transformation matrix   converts displacement vectors natural units   (to_natural=TRUE) natural units   (to_natural=FALSE).  Argument change_time specifies   whether change unit time (TRUE) unit   length (FALSE).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Speed of light and Minkowski metric — sol","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Speed of light and Minkowski metric — sol","text":"Typing “sol(299792458)” lot easier typing   “options(\"c\"=299792458)”, package uses   idiom . R-devel discussion options printing, Martin Maechler   makes following observation: “Good programming style   functions according book depend   arguments, global option really (really? think twice!)   influence behavior, arguments function   default determined global option” think right general, offer observation   speed light depends units chosen, typically one fixes   one's units , subsequently change .   indicate (least) global option   appropriate.  , default, \\(c=1\\),   returned sol() option unset.  just   “default”, though: used overwhelming majority   cases.  Indeed, pedagogically speaking, one learning objective   package units \\(c\\neq 1\\) difficult,   awkward, unnatural.  package R code,   place speed light option accessed via   sol().  Similar arguments presented clifford   package signature.Rd.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Speed of light and Minkowski metric — sol","text":"","code":"sol()                          # returns current speed of light #> [1] 1 sol(299792458)                 # use SI units #> [1] 299792458 sol()                          # speed of light now SI value #> [1] 299792458  eta()                          # note [t,t] term #>               [,1] [,2] [,3] [,4] #> [1,] -8.987552e+16    0    0    0 #> [2,]  0.000000e+00    1    0    0 #> [3,]  0.000000e+00    0    1    0 #> [4,]  0.000000e+00    0    0    1 u <- as.3vel(c(100,200,300))   # fast terrestrial speed, but not relativistic boost(u)                       # boost matrix practically Galilean #>      t             x            y             z #> t    1 -1.112650e-15 -2.22530e-15 -3.337950e-15 #> x -100  1.000000e+00  1.11265e-13  1.668975e-13 #> y -200  1.112650e-13  1.00000e+00  3.337950e-13 #> z -300  1.668975e-13  3.33795e-13  1.000000e+00 is.consistent.boost(boost(u))  # should be TRUE #> [1] TRUE sol(1)                         # revert to relativistic units #> [1] 1"}]
