[{"path":"https://robinhankin.github.io/lorentz/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robin K. S. Hankin. Author, maintainer.","code":""},{"path":"https://robinhankin.github.io/lorentz/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hankin RK (2023). lorentz: Lorentz Transform Relativistic Physics. https://github.com/RobinHankin/lorentz, https://robinhankin.github.io/lorentz/.","code":"@Manual{,   title = {lorentz: The Lorentz Transform in Relativistic Physics},   author = {Robin K. S. Hankin},   year = {2023},   note = {https://github.com/RobinHankin/lorentz, https://robinhankin.github.io/lorentz/}, }"},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"The Lorentz Transform in Relativistic Physics","text":"lorentz package furnishes R-centric functionality special relativity. Lorentz transformations four-vectors handled functionality stress energy tensor given. package deals four-momentum facilities dealing photons mirrors relativistic situations. detailed vignette provided package. original motivation package investigation (nonassociative) gyrogroup structure relativistic three-velocities Einsteinian velocity composition. Natural R idiom may used manipulate vectors three-velocities, although one must careful brackets.","code":""},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"The Lorentz Transform in Relativistic Physics","text":"install recent stable version CRAN, use install.packages() R prompt: install current development version use devtools: load package use library():","code":"R> install.packages(\"lorentz\") R> devtools::install_github(\"RobinHankin/lorentz\") library(\"lorentz\")"},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"the-lorentz-package-in-use","dir":"","previous_headings":"","what":"The lorentz package in use","title":"The Lorentz Transform in Relativistic Physics","text":"package furnishes natural R idiom working three-velocities, four-velocities, Lorentz transformations four--four matrices. Although natural units  used default, can changed. boost matrix can used transform arbitrary four-vectors: can also used transform four-velocities: classical parallelogram law addition velocities incorrect relativistic effects included. combine   terms successive boosts simply multiply boost matrices: note result depends order:","code":"u <- as.3vel(c(0.6,0,0))  # define a three-velocity, 0.6c to the right  u #> A vector of three-velocities (speed of light = 1) #>        x y z #> [1,] 0.6 0 0 as.4vel(u)    # convert to a four-velocity: #> A vector of four-velocities (speed of light = 1) #>         t    x y z #> [1,] 1.25 0.75 0 0 gam(u)  # calculate the gamma term #> [1] 1.25 B <- boost(u) # give the Lorentz transformation B #>       t     x y z #> t  1.25 -0.75 0 0 #> x -0.75  1.25 0 0 #> y  0.00  0.00 1 0 #> z  0.00  0.00 0 1 B %*% (1:4)  # Lorentz transform of an arbitrary four-vector #>    [,1] #> t -0.25 #> x  1.75 #> y  3.00 #> z  4.00 v <- as.4vel(c(0,0.7,-0.2)) B %*% t(v) #>        [,1] #> t  1.823312 #> x -1.093987 #> y  1.021055 #> z -0.291730 boost(u) %*% boost(v) #>           t     x          y          z #> t  1.823312 -0.75 -1.2763187  0.3646625 #> x -1.093987  1.25  0.7657912 -0.2187975 #> y -1.021055  0.00  1.4240348 -0.1211528 #> z  0.291730  0.00 -0.1211528  1.0346151 boost(v) %*% boost(u) #>            t          x          y          z #> t  1.8233124 -1.0939874 -1.0210549  0.2917300 #> x -0.7500000  1.2500000  0.0000000  0.0000000 #> y -1.2763187  0.7657912  1.4240348 -0.1211528 #> z  0.3646625 -0.2187975 -0.1211528  1.0346151"},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"vectorization","dir":"","previous_headings":"","what":"Vectorization","title":"The Lorentz Transform in Relativistic Physics","text":"package fully vectorized can deal vectors whose entries three-velocities four-velocities:","code":"set.seed(0)  options(digits=3)  # generate 5 random three-velocities:  (u <- r3vel(5)) #> A vector of three-velocities (speed of light = 1) #>           x       y      z #> [1,]  0.230  0.0719  0.314 #> [2,] -0.311  0.4189 -0.277 #> [3,] -0.185  0.5099 -0.143 #> [4,] -0.739 -0.4641  0.129 #> [5,] -0.304 -0.2890  0.593  # calculate the gamma correction term:  gam(u) #> [1] 1.09 1.24 1.21 2.13 1.46  # add a velocity of 0.9c in the x-direction:  v <- as.3vel(c(0.9,0,0))  v+u #> A vector of three-velocities (speed of light = 1) #>          x      y      z #> [1,] 0.936  0.026  0.113 #> [2,] 0.818  0.253 -0.168 #> [3,] 0.858  0.267 -0.075 #> [4,] 0.480 -0.605  0.168 #> [5,] 0.820 -0.174  0.356  # convert u to a four-velocity:  as.4vel(u) #> A vector of four-velocities (speed of light = 1) #>         t      x       y      z #> [1,] 1.09  0.250  0.0783  0.341 #> [2,] 1.24 -0.385  0.5190 -0.343 #> [3,] 1.21 -0.223  0.6160 -0.173 #> [4,] 2.13 -1.571 -0.9862  0.273 #> [5,] 1.46 -0.443 -0.4209  0.864  # use four-velocities to effect the same transformation:  w <- as.4vel(u) %*% boost(-v)  as.3vel(w) #> A vector of three-velocities (speed of light = 1) #>          x      y      z #> [1,] 0.936  0.026  0.113 #> [2,] 0.818  0.253 -0.168 #> [3,] 0.858  0.267 -0.075 #> [4,] 0.480 -0.605  0.168 #> [5,] 0.820 -0.174  0.356"},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"three-velocities","dir":"","previous_headings":"","what":"Three-velocities","title":"The Lorentz Transform in Relativistic Physics","text":"Three-velocites behave interesting counter-intuitive ways. three-velocity addition law given Ungar. can see velocity addition commutative: Observe difference u+v v+u “small” sense. Commutativity replaced gyrocommutatitivity: (, zero numerical accuracy)","code":"u <- as.3vel(c(0.2,0.4,0.1))   # single three-velocity  v <- r3vel(4,0.9)              # 4 random three-velocities with speed 0.9  w <- as.3vel(c(-0.5,0.1,0.3))  # single three-velocity u+v #> A vector of three-velocities (speed of light = 1) #>           x      y     z #> [1,]  0.702 -0.113 0.567 #> [2,] -0.679  0.580 0.102 #> [3,] -0.046  0.879 0.364 #> [4,]  0.312  0.407 0.788  v+u #> A vector of three-velocities (speed of light = 1) #>           x      y     z #> [1,]  0.624 -0.378 0.543 #> [2,] -0.823  0.358 0.045 #> [3,] -0.234  0.832 0.401 #> [4,]  0.228  0.190 0.892  (u+v)-(v+u) #> A vector of three-velocities (speed of light = 1) #>          x     y       z #> [1,] 0.243 0.506  0.1190 #> [2,] 0.201 0.490  0.1206 #> [3,] 0.503 0.245 -0.0519 #> [4,] 0.242 0.564 -0.1105 # Compare two different ways of calculating the same thing:  (u+v) - gyr(u,v,v+u)   #> A vector of three-velocities (speed of light = 1) #>              x         y         z #> [1,]  3.53e-15 -1.20e-15  2.89e-15 #> [2,]  2.89e-16 -3.18e-15 -1.08e-16 #> [3,] -4.26e-15  1.09e-13  4.67e-14 #> [4,]  1.67e-15  4.76e-16  1.91e-15 # The other way round:  (v+u) - gyr(v,u,u+v) #> A vector of three-velocities (speed of light = 1) #>             x         y         z #> [1,] 3.21e-15 -6.42e-16  2.89e-15 #> [2,] 3.76e-15 -1.73e-15 -2.53e-16 #> [3,] 1.47e-14 -4.07e-14 -2.03e-14 #> [4,] 9.05e-15  6.43e-15  3.24e-14"},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"nonassociativity-of-three-velocities","dir":"","previous_headings":"","what":"Nonassociativity of three-velocities","title":"The Lorentz Transform in Relativistic Physics","text":"reasonable expect u+(v+w)==(u+v)+w. However, case: (, significant departure associativity). Associativity replaced gyroassociativity: (zero numerical accuracy).","code":"((u+v)+w) - (u+(v+w)) #> A vector of three-velocities (speed of light = 1) #>             x       y         z #> [1,]  0.00613  0.0794 -0.001467 #> [2,] -0.11096 -0.1508 -0.031226 #> [3,] -0.10748 -0.1022  0.000795 #> [4,] -0.05772 -0.0631 -0.007364 (u+(v+w)) - ((u+v)+gyr(u,v,w)) #> A vector of three-velocities (speed of light = 1) #>      x         y         z #> [1,] 0  8.16e-17 -6.53e-16 #> [2,] 0 -9.49e-16  0.00e+00 #> [3,] 0  3.21e-15  1.60e-15 #> [4,] 0  0.00e+00  0.00e+00  ((u+v)+w) - (u+(v+gyr(v,u,w))) #> A vector of three-velocities (speed of light = 1) #>              x         y         z #> [1,]  0.00e+00  4.03e-17 -1.29e-15 #> [2,] -1.81e-15  9.07e-16  0.00e+00 #> [3,]  0.00e+00  1.37e-14  5.48e-15 #> [4,]  0.00e+00 -1.84e-15 -1.84e-15"},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"The Lorentz Transform in Relativistic Physics","text":"concise reference . . Ungar 2006. Thomas precession: kinematic effect algebra Einstein’s velocity addition law. Comments “Deriving relativistic momentum energy: II, Three-dimensional case. European Journal Physics, 27:L17-L20","code":""},{"path":"https://robinhankin.github.io/lorentz/index.html","id":"further-information","dir":"","previous_headings":"","what":"Further information","title":"The Lorentz Transform in Relativistic Physics","text":"detail, see package vignette","code":"vignette(\"lorentz\")"},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":null,"dir":"Reference","previous_headings":"","what":"Three velocities — 3vel","title":"Three velocities — 3vel","text":"Create test three-velocities, 3vel objects.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Three velocities — 3vel","text":"","code":"`3vel`(n) threevel(n) as.3vel(x) is.3vel(x) # S3 method for vec length(x) # S3 method for vec names(x) # S3 method for vec names(x) <- value"},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Three velocities — 3vel","text":"n function 3vel(), number three velocities     create x,value Vectors three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Three velocities — 3vel","text":"Class vel virtual class containing classes 3vel   4vel. Function threevel() convenience wrapper 3vel().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Three velocities — 3vel","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/3vel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Three velocities — 3vel","text":"","code":"U <- r4vel(7) as.4vel(as.3vel(U)) # equal to U, to numerical precision #> A vector of four-velocities (speed of light = 1) #>             t          x           y          z #> [1,] 1.959171  0.3347167 -0.55694893  1.5543881 #> [2,] 1.248719 -0.4089316  0.05031264 -0.6241342 #> [3,] 1.865701 -1.2070402 -0.85311164  0.5441444 #> [4,] 1.137445  0.2439730 -0.43965039  0.2024001 #> [5,] 2.234274  0.5380600 -0.09259956 -1.9219513 #> [6,] 1.860832 -0.5826970  1.40697476  0.3789218 #> [7,] 2.055661 -0.5052599  1.42196236  0.9738988  x <- as.3vel(1:3/4) u <- as.3vel(matrix(runif(30)/10,ncol=3))  names(u) <- letters[1:10]  x+u #> A vector of three-velocities (speed of light = 1) #>           x         y         z #> a 0.2665310 0.5099206 0.7489696 #> b 0.2587769 0.5077982 0.7560239 #> c 0.2656994 0.5020706 0.7496600 #> d 0.2630747 0.4993986 0.7569862 #> e 0.2767373 0.4963674 0.7568674 #> f 0.2500150 0.5130951 0.7530093 #> g 0.2671194 0.5140892 0.7515606 #> h 0.2782617 0.5040831 0.7478495 #> i 0.2717096 0.4893863 0.7635701 #> j 0.2674056 0.4980403 0.7526570 u+x  # not equal #> A vector of three-velocities (speed of light = 1) #>           x         y         z #> a 0.2935252 0.5192583 0.7322752 #> b 0.2699872 0.5110984 0.7498547 #> c 0.2925068 0.5004372 0.7407183 #> d 0.2836079 0.4888899 0.7564315 #> e 0.3226228 0.4766588 0.7513476 #> f 0.2450731 0.5285034 0.7439223 #> g 0.2936788 0.5271872 0.7323320 #> h 0.3275776 0.5020881 0.7289778 #> i 0.3077086 0.4557018 0.7707241 #> j 0.2971420 0.4879454 0.7481032"},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":null,"dir":"Reference","previous_headings":"","what":"Four momentum — 4mom","title":"Four momentum — 4mom","text":"Create test four-momentum","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Four momentum — 4mom","text":"","code":"# S3 method for 4mom Ops(e1, e2) # S3 method for 4mom sum(..., na.rm=FALSE) vel_to_4mom(U,m=1) p_to_4mom(p,E=1) as.4mom(x) is.4mom(x) fourmom_mult(P,n) fourmom_add(e1,e2)"},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Four momentum — 4mom","text":"x,P,e1,e2 Four-momentum p Three-momentum E Scalar; energy U Object coerced four-velocity m Scalar; rest mass n Multiplying factor ...,na.rm Arguments sent sum()","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Four momentum — 4mom","text":"Four-momentum relativistic generalization three-momentum, object's energy first element.  can defined \\(mU\\), \\(m\\) rest mass \\(U\\) four-velocity. Equivalently, one can define four-momentum \\((E/c,p_x,p_y,p_z)\\) \\(E\\) energy \\((p_x,p_y,p_z)\\) three-momentum. Function vel_to_4mom() converts three-velocity four-momentum, function p_to_4mom()) converts three-momentum four-momentum. function Ops.4mom() passes unary binary arithmetic operators “+”, “-” “*” appropriate specialist function. package designed natural R idiom may used physically meaningful operations combining momenta different objects, using conservation four-momentum. four-momentum photon, use .photon().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Four momentum — 4mom","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/4mom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Four momentum — 4mom","text":"","code":"# Define 5 random three velocities: v <- r3vel(5)  # convert to four-velocity: as.4vel(v) #> A vector of four-velocities (speed of light = 1) #>             t           x          y           z #> [1,] 1.662784 -0.18416346  0.2545614 -1.29078800 #> [2,] 1.306469  0.83104926 -0.1246870 -0.02593303 #> [3,] 1.652081 -0.83271559  0.4299081  0.92257044 #> [4,] 2.198360 -1.52438026  1.1987900 -0.26824303 #> [5,] 1.323461  0.07992067 -0.8097099  0.29921953  # Now convert 'v' to four-momentum, specifying rest mass: vel_to_4mom(v)         # 4mom of five objects with 3vel v, all unit mass #>             E         p_x        p_y         p_z #> [1,] 1.662784 -0.18416346  0.2545614 -1.29078800 #> [2,] 1.306469  0.83104926 -0.1246870 -0.02593303 #> [3,] 1.652081 -0.83271559  0.4299081  0.92257044 #> [4,] 2.198360 -1.52438026  1.1987900 -0.26824303 #> [5,] 1.323461  0.07992067 -0.8097099  0.29921953 vel_to_4mom(v,   1:5)  # 4mom of five objects with 3vel v, masses 1-5 #>             E        p_x        p_y         p_z #> [1,] 1.662784 -0.1841635  0.2545614 -1.29078800 #> [2,] 2.612939  1.6620985 -0.2493740 -0.05186606 #> [3,] 4.956244 -2.4981468  1.2897244  2.76771133 #> [4,] 8.793440 -6.0975210  4.7951601 -1.07297213 #> [5,] 6.617306  0.3996033 -4.0485496  1.49609767 vel_to_4mom(v[1],1:5)  # 4mom of five objects with same 3vel, masses 1..5 #>             E        p_x       p_y       p_z #> [1,] 1.662784 -0.1841635 0.2545614 -1.290788 #> [2,] 3.325568 -0.3683269 0.5091228 -2.581576 #> [3,] 4.988353 -0.5524904 0.7636843 -3.872364 #> [4,] 6.651137 -0.7366538 1.0182457 -5.163152 #> [5,] 8.313921 -0.9208173 1.2728071 -6.453940  # Now convert 'v' to four-momentum, specifying energy E: p_to_4mom(v,E=1) #>      E         p_x         p_y        p_z #> [1,] 1 -0.11075608  0.15309348 -0.7762811 #> [2,] 1  0.63610313 -0.09543815 -0.0198497 #> [3,] 1 -0.50404034  0.26022214  0.5584292 #> [4,] 1 -0.69341700  0.54531104 -0.1220196 #> [5,] 1  0.06038761 -0.61181231  0.2260886 p_to_4mom(v,E=10)   # slower #>       E         p_x         p_y        p_z #> [1,] 10 -0.11075608  0.15309348 -0.7762811 #> [2,] 10  0.63610313 -0.09543815 -0.0198497 #> [3,] 10 -0.50404034  0.26022214  0.5584292 #> [4,] 10 -0.69341700  0.54531104 -0.1220196 #> [5,] 10  0.06038761 -0.61181231  0.2260886 p_to_4mom(v,E=100)  # even slower #>        E         p_x         p_y        p_z #> [1,] 100 -0.11075608  0.15309348 -0.7762811 #> [2,] 100  0.63610313 -0.09543815 -0.0198497 #> [3,] 100 -0.50404034  0.26022214  0.5584292 #> [4,] 100 -0.69341700  0.54531104 -0.1220196 #> [5,] 100  0.06038761 -0.61181231  0.2260886  # Four-momentum of objects moving closely parallel to the x-axis: P <- vel_to_4mom(as.3vel(c(0.8,0,0)) + r3vel(7,0.01))  reflect(P) #>             E       p_x           p_y           p_z #> [1,] 1.670809 -1.338473 -0.0021428368  0.0092818190 #> [2,] 1.671897 -1.339833  0.0040538768 -0.0082871379 #> [3,] 1.662050 -1.327526 -0.0008652552  0.0093186954 #> [4,] 1.671351 -1.339151  0.0081014892  0.0047400752 #> [5,] 1.658732 -1.323378 -0.0075396183  0.0026461479 #> [6,] 1.659608 -1.324472  0.0053829531 -0.0065069057 #> [7,] 1.654732 -1.318377  0.0043292618 -0.0001339384 reflect(P,c(1,1,1)) #>             E       p_x        p_y        p_z #> [1,] 1.670809 0.4509171 -0.8854134 -0.8968381 #> [2,] 1.671897 0.4437889 -0.9000983 -0.8877572 #> [3,] 1.662050 0.4481441 -0.8785162 -0.8887001 #> [4,] 1.671351 0.4549448 -0.8923079 -0.8889465 #> [5,] 1.658732 0.4378635 -0.8779744 -0.8881601 #> [6,] 1.659608 0.4407414 -0.8891137 -0.8772239 #> [7,] 1.654732 0.4422559 -0.8804503 -0.8759871  sum(P) #>             E     p_x         p_y         p_z #> [1,] 11.64918 9.31121 -0.01131987 -0.01105876"},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":null,"dir":"Reference","previous_headings":"","what":"Four velocities — 4vel","title":"Four velocities — 4vel","text":"Create test four-velocities.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Four velocities — 4vel","text":"","code":"as.4vel(u) is.consistent.4vel(U, give=FALSE, TOL=1e-10) inner4(U,V=U) to3(U)"},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Four velocities — 4vel","text":"u vector three-velocities U,V vector four-velocities give function .consistent.4vel(), Boolean     TRUE meaning return \\(U\\cdot U+c^2\\),     zero four-velocity, default FALSE meaning return     whether four-velocity consistent numerical precision TOL Small positive value used tolerance","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Four velocities — 4vel","text":"Function .4vel() takes three-velocity returns   four-velocity. Given four-vector \\(V\\), function inner4() returns   Lorentz invariant \\(V^iV_i=\\eta_{ij}V^iV^j\\).    quantity unchanged Lorentz transforms.  Note function   inner4() works four-vector, just four-velocities.   work (eg) four-displacement, four-momentum vector   four-frequency.  electromagnetism, four-current   four-potential.  \\(U\\) four-velocity,   \\(U^iU_i=-c^2\\); \\(U\\) 4-displacement, \\(U^iU_i\\)   squared interval.  \\(P\\) four-momentum photon   \\(P^iP_i=0\\). Function to3() low-level helper function used   .3vel() given four-velocity. Function .consistent.4vel() checks four-velocities   consistent sense \\(U^iU_i=-c^2\\).  Giving   function vector, example, .consistent.4vel(1:5),   return error. Compare functions documented boost(),   returns \\(4\\times 4\\) transformation matrix (also   includes rotation information).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Four velocities — 4vel","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/4vel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Four velocities — 4vel","text":"","code":"a <- r3vel(10) as.4vel(a)     # a four-velocity #> A vector of four-velocities (speed of light = 1) #>              t          x          y           z #>  [1,] 1.350206  0.6418679  0.4417052  0.46471337 #>  [2,] 1.193483 -0.3214997  0.5662317 -0.02054354 #>  [3,] 3.299963  1.2296996 -2.8942000 -0.03461664 #>  [4,] 2.157699 -0.9460191 -1.6481056  0.21085370 #>  [5,] 3.543390 -2.1466415  0.5983768  2.56699941 #>  [6,] 2.096973 -0.7195692  0.3145041 -1.66751460 #>  [7,] 8.161490  3.8814251  4.4822471  5.51850648 #>  [8,] 1.206358 -0.5977740 -0.2777891  0.14422161 #>  [9,] 1.477068  0.1950323  0.2626108 -1.03669072 #> [10,] 1.418791 -0.2043264 -0.8807578  0.44213759  as.3vel(as.4vel(a))-a   # zero to numerical precision #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,] -2.529999e-17  2.529999e-17 -5.059998e-17 #>  [2,] -2.965133e-17  7.907022e-17 -1.235472e-18 #>  [3,] -6.045027e-16  1.209005e-15  9.445355e-18 #>  [4,] -1.292206e-16  0.000000e+00  0.000000e+00 #>  [5,]  6.969764e-16 -3.484882e-16 -1.393953e-15 #>  [6,] -1.220495e-16  0.000000e+00 -2.440991e-16 #>  [7,]  0.000000e+00 -3.697593e-15  0.000000e+00 #>  [8,] -2.019635e-17 -3.029452e-17  1.009817e-17 #>  [9,]  3.027758e-17  6.055516e-17 -1.816655e-16 #> [10,]  0.000000e+00 -1.117422e-16  5.587112e-17  inner4(as.4vel(a))   #  -1 to numerical precision #>  [1] -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  stopifnot(all(is.consistent.4vel(as.4vel(a))))   ## check Lorentz invariance of dot product: U <- as.4vel(r3vel(10)) V <- as.4vel(r3vel(10)) B <- boost(as.3vel(1:3/10))  frame1dotprod <- inner4(U, V) frame2dotprod <- inner4(U %*% B, V %*% B) max(abs(frame1dotprod-frame2dotprod))  # zero to numerical precision #> [1] 2.664535e-15"},{"path":"https://robinhankin.github.io/lorentz/reference/Extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract or replace parts of three-velocity — Extract.3vel","title":"Extract or replace parts of three-velocity — Extract.3vel","text":"Extract replace subsets three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract or replace parts of three-velocity — Extract.3vel","text":"x three-vector index elements extract replace value replacement value","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Extract.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract or replace parts of three-velocity — Extract.3vel","text":"methods () work expected: object class 3vel three-column matrix rows corresponding three-velocities; single argument interpreted row number. Salient use-cases u[1:5] <- u[1] u[1] <- 0. extract single component, pass second index: u[,1] returns x- component three-velocity. Extraction functions take drop argument, except x[] returns vec object. Currently, u[] returns u sure desirable.  Maybe return unclass(u) perhaps c(unclass(u)). Use idiom u[] <- x replace entries u elementwise.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Extract.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract or replace parts of three-velocity — Extract.3vel","text":"","code":"u <- r3vel(10) u[1:4] #> A vector of three-velocities (speed of light = 1) #>               x          y          z #> [1,]  0.3076805 -0.2730680  0.2266037 #> [2,] -0.5805091  0.4558348 -0.2133571 #> [3,]  0.2125307  0.2456534  0.9014044 #> [4,]  0.7873583 -0.3007481  0.2867230 u[5:6] <- 0  u[7:8] <- u[1]  u[,1] <- 0.1"},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"Arithmetic operations three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"","code":"# S3 method for 3vel Ops(e1, e2) # S3 method for 4vel Ops(e1, e2) massage3(u,v) neg3(u) prod3(u,v=u) add3(u,v) dot3(v,r)"},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"e1,e2,u,v Objects class “3vel”,     three-velocities r Scalar value circle-dot multiplication","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"function Ops.3vel() passes unary binary arithmetic   operators “+”, “-” “*”   appropriate specialist function. interesting operators “+”   “*”, passed add3() dot3()   respectively.  defined, following Ungar, : $$     \\mathbf{u}+\\mathbf{v} = \\frac{1}{1+\\mathbf{u}\\cdot\\mathbf{b}/c^2}     \\left\\{     \\mathbf{u} +     \\frac{1}{\\gamma_\\mathbf{u}}\\mathbf{v} +     \\frac{1}{c^2}\\frac{\\gamma_\\mathbf{u}}{1+\\gamma_\\mathbf{u}}     \\left(\\mathbf{u}\\cdot\\mathbf{v}\\right)\\mathbf{u}     \\right\\}   $$ $$     r\\odot\\mathbf{v} =     c\\tanh\\left(     r\\tanh^{-1}\\frac{\\left|\\left|\\mathbf{v}\\right|\\right|}{c}     \\right)\\frac{\\mathbf{v}}{\\left|\\left|\\mathbf{v}\\right|\\right|}   $$ \\(\\mathbf{u}\\) \\(\\mathbf{v}\\) three-vectors   \\(r\\) scalar.  Function dot3() special dispensation   zero velocity treat NA entries entirely   consistently. Arithmetic operations, executed via Ops.4vel(), defined   four-velocities. package designed natural R idiom may used three   velocity addition, see examples section.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"Returns object class 3vel, except prod3() returns numeric vector.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/Ops.3vec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic Ops Group Methods for 3vel objects — Ops.3vel","text":"","code":"u <- as.3vel(c(-0.7, 0.1,-0.1)) v <- as.3vel(c( 0.1, 0.2, 0.3)) w <- as.3vel(c( 0.5, 0.2,-0.3))  x <- r3vel(10)   # random three velocities y <- r3vel(10)   # random three velocities   u+v   # add3(u,v) #> A vector of three-velocities (speed of light = 1) #>              x         y         z #> [1,] -0.648977 0.2557545 0.1246803 u-v   # add3(u,neg3(v)) #> A vector of three-velocities (speed of light = 1) #>               x           y          z #> [1,] -0.7434641 -0.03267974 -0.2913943  -v    # neg3(v) #> A vector of three-velocities (speed of light = 1) #>         x    y    z #> [1,] -0.1 -0.2 -0.3  gyr(u,v,w) #> A vector of three-velocities (speed of light = 1) #>              x         y          z #> [1,] 0.5134003 0.2390541 -0.2434611  ## package is vectorized:   u+x #> A vector of three-velocities (speed of light = 1) #>                 x          y            z #>  [1,] -0.79311655  0.4149469  0.232622395 #>  [2,]  0.25661372 -0.1461787  0.050785344 #>  [3,] -0.82553935  0.1174465 -0.009033805 #>  [4,] -0.76374363  0.3373975 -0.341307582 #>  [5,] -0.82916297  0.3970941  0.344254794 #>  [6,] -0.04925176 -0.1107449  0.016463628 #>  [7,] -0.35546083  0.1554481  0.538170253 #>  [8,] -0.50402077  0.1289919 -0.604431792 #>  [9,] -0.59320893  0.5371619 -0.375195098 #> [10,] -0.87494371  0.3660709  0.152498397 x+y #> A vector of three-velocities (speed of light = 1) #>                x           y            z #>  [1,] -0.2514903  0.54008902  0.559415592 #>  [2,]  0.3883998 -0.17750560  0.690783417 #>  [3,] -0.5634785  0.52781791 -0.523628443 #>  [4,] -0.5052179  0.38959627 -0.145376462 #>  [5,] -0.2214281  0.73031741  0.638270149 #>  [6,]  0.9274247 -0.07871253  0.354485090 #>  [7,] -0.2999187  0.26816667  0.759634816 #>  [8,]  0.7581581 -0.29502927 -0.493154043 #>  [9,]  0.7535573  0.36338922 -0.003238339 #> [10,] -0.5008196  0.33143403 -0.789007961  f <- gyrfun(u,v) g <- gyrfun(v,u)  f(g(x)) - x    # should be zero by eqn10 #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,]  8.906206e-16 -5.699972e-16 -3.562483e-16 #>  [2,] -3.580559e-16  2.685419e-16  8.951398e-17 #>  [3,] -4.520977e-16  2.060747e-16  8.769136e-17 #>  [4,] -3.962152e-16 -7.203913e-17  1.200652e-16 #>  [5,] -1.071561e-15  1.071561e-15  1.071561e-15 #>  [6,] -2.201181e-16  1.513312e-16  1.375738e-16 #>  [7,] -2.522240e-16  1.221710e-16 -7.566721e-16 #>  [8,] -2.306045e-16  1.393236e-16  1.024909e-16 #>  [9,] -3.152862e-16 -5.675152e-16  2.522290e-16 #> [10,] -3.443055e-15  2.754444e-15  1.869087e-15 g(f(x)) - x #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,]  3.562483e-17  7.837462e-16  4.987476e-16 #>  [2,] -3.580559e-16  1.790280e-16  6.713548e-17 #>  [3,] -6.196856e-16  1.973056e-16  1.987671e-16 #>  [4,]  1.680913e-16 -4.802609e-16  5.523000e-16 #>  [5,] -2.143122e-15  5.357804e-16  1.071561e-15 #>  [6,] -2.201181e-16  1.100591e-16  2.751476e-17 #>  [7,] -6.305601e-16  2.167550e-16 -1.891680e-16 #>  [8,] -4.099636e-16  1.649463e-16  0.000000e+00 #>  [9,] -5.044580e-16  6.305725e-16  0.000000e+00 #> [10,]  3.934920e-16 -8.853570e-16 -7.869840e-16   (u+v) - f(v+u)                     # zero by eqn 10 #> A vector of three-velocities (speed of light = 1) #>                  x            y            z #> [1,] -6.132309e-16 1.951189e-16 1.672448e-16 (u+(v+w)) - ((u+v)+f(w))           # zero by eqn 11 #> A vector of three-velocities (speed of light = 1) #>                  x y             z #> [1,] -5.469679e-17 0 -5.469679e-18 ((u+v)+w) - (u+(v+g(w)))           # zero by eqn 11 #> A vector of three-velocities (speed of light = 1) #>                 x            y            z #> [1,] 3.951349e-16 -2.99021e-16 1.975675e-16   ## NB, R idiom is unambiguous.  But always always ALWAYS use brackets.  ## Ice report in lat 42.n to 41.25n Long 49w to long 50.30w saw much ## heavy pack ice and great number large icebergs also field ## ice.  Weather good clear  ## -u+v == (-u) + v == neg3(u) + v == add3(neg3(u),v)  ## u+v+w == (u+v)+w == add3(add3(u,v),w)"},{"path":"https://robinhankin.github.io/lorentz/reference/as.matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","title":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","text":"Coerce 3-vectors 4-vectors matrix.  convenience wrapper unclass()","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/as.matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","text":"","code":"# S3 method for 3vel as.matrix(x, ...) # S3 method for 4vel as.matrix(x, ...)"},{"path":"https://robinhankin.github.io/lorentz/reference/as.matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","text":"x Object class 3vel 4vel ... arguments (currently ignored)","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/as.matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/as.matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce 3-vectors and 4-vectors to a matrix — as.matrix.3vel","text":"","code":"as.matrix(r3vel(5)) #>                x          y           z #> [1,] -0.59780473  0.6670237 -0.16486474 #> [2,] -0.69525653  0.1062860 -0.45690132 #> [3,]  0.97425984  0.1729935  0.03148879 #> [4,] -0.68174018 -0.2159213 -0.45832248 #> [5,] -0.02750415  0.5247686 -0.20588787 as.matrix(r4vel(5)) #>             t           x           y          z #> [1,] 1.135660 -0.27842706 -0.20790674  0.4110673 #> [2,] 1.210426 -0.51101371 -0.07736919 -0.4449841 #> [3,] 1.197062  0.14064649 -0.32574742  0.5541335 #> [4,] 1.036075 -0.08686639  0.10531652 -0.2341221 #> [5,] 2.046521 -1.32343558  0.94036366  0.7432916"},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":null,"dir":"Reference","previous_headings":"","what":"Lorentz transformations — boost","title":"Lorentz transformations — boost","text":"Lorentz transformations: boosts rotations","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lorentz transformations — boost","text":"","code":"boost(u=0) rot(u,v,space=TRUE) is.consistent.boost(L, give=FALSE, TOL=1e-10) is.consistent.boost.galilean(L, give=FALSE, TOL=1e-10) pureboost(L,include_sol=TRUE) orthog(L) pureboost.galilean(L, tidy=TRUE) orthog.galilean(L)"},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lorentz transformations — boost","text":"u,v Three-velocities, coerced  class 3vel.      function boost(), u takes special default value     0, interpreted zero three velocity L Lorentz transform expressed \\(4\\times 4\\) matrix TOL Numerical tolerance give Boolean TRUE meaning return transformed     metric tensor (flat-space eta(); qv)     default FALSE meaning return whether matrix     consistent boost space Boolean, default TRUE meaning return just     spatial component rotation matrix FALSE     meaning return full \\(4\\times 4\\) matrix     transformation tidy pureboost.galilean(), Boolean default     TRUE meaning return “tidy” boost matrix     spatial components forced \\(3\\times 3\\) identity     matrix include_sol function pureboost(), Boolean     default TRUE meaning correctly account speed     light, FALSE meaning assume \\(c=1\\). See details","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lorentz transformations — boost","text":"Function boost() returns \\(4\\times 4\\) matrix; function rot() returns orthogonal matrix.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lorentz transformations — boost","text":"Arguments u,v coerced three-velocities. rotation-free Lorentz transformation known boost   (sometimes pure boost), expressed matrix form.  Pure   boost matrices symmetric \\(c=1\\).  Function boost(u)   returns \\(4\\times 4\\) matrix giving Lorentz transform   arbitrary three-velocity u. Boosts can successively applied regular matrix multiplication.   However, composing two successive pure boosts general   return pure boost matrix: product symmetric general.   Also note boost matrices commute.  resulting matrix   product represents Lorentz transform. possible decompose Lorentz transform \\(L\\) pure   boost spatial rotation.  Thus \\(L=OP\\) \\(O\\)   orthogonal matrix \\(P\\) pure boost matrix; returned   functions orthog() pureboost() respectively.     speed light equal 1, functions still work can   confusing. Functions pureboost.galilean() orthog.galilean()   Newtonian equivalents pureboost() orthog(),   intended used speed light infinite (causes   problems relativistic functions). noted , composition two pure Lorentz boosts   necessarily pure.  two successive boosts corresponding   \\(u\\) \\(v\\), composed boost may decomposed   pure boost boost(u+v) rotation rot(u,v). reason argument include_sol exists function   orthog() needs call pureboost() environment   pretend \\(c=1\\).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lorentz transformations — boost","text":"Ungar 2006. “Thomas precession: kinematic       effect...”. European Journal Physics, 27:L17-L20 Sbitneva 2001. “Nonassociative geometry special relativity”.     International Journal Theoretical Physics, volume 40, number 1,       pages 359--362 Wikipedia contributors 2018.  “Wigner rotation”,   Wikipedia, Free Encyclopedia.   https://en.wikipedia.org/w/index.php?title=Wigner_rotation&oldid=838661305.  Online; accessed 23 August 2018","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Lorentz transformations — boost","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Lorentz transformations — boost","text":"Function rot() uses crossprod() efficiency reasons algebraically equivalent boost(-u-v) %*% boost(u) %*% boost(v).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/boost.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lorentz transformations — boost","text":"","code":"boost(as.3vel(c(0.4,-0.2,0.1))) #>            t           x           y           z #> t  1.1250879 -0.45003516  0.22501758 -0.11250879 #> x -0.4500352  1.09530507 -0.04765253  0.02382627 #> y  0.2250176 -0.04765253  1.02382627 -0.01191313 #> z -0.1125088  0.02382627 -0.01191313  1.00595657  u <- r3vel(1) v <- r3vel(1) w <- r3vel(1)  boost(u) - solve(boost(-u))  # should be zero #>               t             x             y             z #> t  4.440892e-16 -2.220446e-16 -1.110223e-16  0.000000e+00 #> x  0.000000e+00  0.000000e+00 -2.775558e-17 -5.551115e-17 #> y -1.110223e-16 -5.551115e-17  2.220446e-16 -1.665335e-16 #> z  0.000000e+00 -3.330669e-16 -5.551115e-17  2.220446e-16  boost(u) %*% boost(v)   # not a pure boost (not symmetrical) #>           t         x          y          z #> t  2.849941  2.333202 0.07376089  1.2934042 #> x  1.899583  2.104168 0.19331868  0.3788383 #> y -0.459072 -0.461417 0.97099268 -0.2345521 #> z  1.817417  1.342907 0.15887658  1.5730102 boost(u+v)  # not the same! #>           t          x          y          z #> t  2.849941  1.8995829 -0.4590720  1.8174165 #> x  1.899583  1.9372650 -0.2265087  0.8967236 #> y -0.459072 -0.2265087  1.0547403 -0.2167111 #> z  1.817417  0.8967236 -0.2167111  1.8579359 boost(v+u)  # also not the same! #>            t          x          y          z #> t 2.84994122 2.33320165 0.07376089 1.29340417 #> x 2.33320165 2.41400340 0.04470173 0.78384904 #> y 0.07376089 0.04470173 1.00141318 0.02478028 #> z 1.29340417 0.78384904 0.02478028 1.43452464  u+v  # returns a three-velocity #> A vector of three-velocities (speed of light = 1) #>               x         y          z #> [1,] -0.6665341 0.1610812 -0.6377032   boost(u) %*% boost(v) %*% boost(w)  # associative, no brackets needed #>            t          x           y           z #> t  3.3337703  3.1601238 -0.28236078 -0.21889400 #> x  2.6209911  2.7086860 -0.06702243 -0.72672031 #> y -0.6711525 -0.6125572  1.03608262  0.04185737 #> z  1.6715217  1.8094685 -0.04205234  0.71975005 boost(u+(v+w))  # not the same! #>            t          x          y          z #> t  3.3337703  2.6209911 -0.6711525  1.6715217 #> x  2.6209911  2.5851311 -0.4059017  1.0109081 #> y -0.6711525 -0.4059017  1.1039385 -0.2588614 #> z  1.6715217  1.0109081 -0.2588614  1.6447007 boost((u+v)+w)  # also not the same! #>            t          x          y          z #> t  2.9954570  2.3493970 -0.6227797  1.4370950 #> x  2.3493970  2.3814856 -0.3662051  0.8450364 #> y -0.6227797 -0.3662051  1.0970739 -0.2240028 #> z  1.4370950  0.8450364 -0.2240028  1.5168975   rot(u,v) #>            x         y           z #> x  0.9529534 0.1569246 -0.25933464 #> y -0.1832030 0.9797880 -0.08032489 #> z  0.2414880 0.1240568  0.96244140 rot(v,u)    # transpose (=inverse) of rot(u,v) #>            x           y         z #> x  0.9529534 -0.18320299 0.2414880 #> y  0.1569246  0.97978803 0.1240568 #> z -0.2593346 -0.08032489 0.9624414   rot(u,v,FALSE) %*% boost(v) %*% boost(u) #>           t          x          y          z #> t  2.849941  1.8995829 -0.4590720  1.8174165 #> x  1.899583  1.9372650 -0.2265087  0.8967236 #> y -0.459072 -0.2265087  1.0547403 -0.2167111 #> z  1.817417  0.8967236 -0.2167111  1.8579359 boost(u+v)     # should be the same. #>           t          x          y          z #> t  2.849941  1.8995829 -0.4590720  1.8174165 #> x  1.899583  1.9372650 -0.2265087  0.8967236 #> y -0.459072 -0.2265087  1.0547403 -0.2167111 #> z  1.817417  0.8967236 -0.2167111  1.8579359   orthog(boost(u) %*% boost(v)) - rot(u,v,FALSE)  # zero to numerical precision #>               t             x             y             z #> t  4.440892e-14 -3.919168e-14 -1.345383e-15 -1.990908e-14 #> x -3.926748e-14  3.463896e-14  9.992007e-16  1.759703e-14 #> y  8.685658e-15 -7.688294e-15 -3.330669e-16 -3.982925e-15 #> z -2.490086e-14  2.348122e-14  7.077672e-16  1.232348e-14 pureboost(boost(v) %*% boost(u)) - boost(u+v)   # ditto #>               t             x             y             z #> t  0.000000e+00 -2.442491e-15  4.440892e-16 -1.998401e-15 #> x -2.442491e-15  2.220446e-16 -2.220446e-16  1.110223e-16 #> y  4.440892e-16 -2.220446e-16  2.220446e-16  5.551115e-17 #> z -1.998401e-15  1.110223e-16  8.326673e-17  1.332268e-15   ## Define a random-ish Lorentz transform L <- boost(r3vel(1)) %*% boost(r3vel(1)) %*% boost(r3vel(1))  ## check it:   if (FALSE)    # needs emulator package quad.form(eta(),L)  # should be eta()   ## More concisely: is.consistent.boost(L)     # should be TRUE #> [1] TRUE  ## Decompose L into a rotation and a pure boost: U <- orthog(L) P <- pureboost(L)  L - U %*% P              # should be zero (L = UP) #>              t            x            y             z #> t 1.385558e-13 8.171241e-14 7.327472e-15 -1.154632e-13 #> x 1.705303e-13 9.503509e-14 8.104628e-15 -1.421085e-13 #> y 2.486900e-14 1.820766e-14 1.443290e-15 -1.865175e-14 #> z 7.638334e-14 4.662937e-14 3.774758e-15 -6.039613e-14 crossprod(U)               # should be identity (U is orthogonal) #>               t             x             y             z #> t  1.000000e+00  2.385745e-11  2.114837e-12 -3.372738e-11 #> x  2.385745e-11  1.000000e+00 -1.217399e-12  1.941662e-11 #> y  2.114837e-12 -1.217399e-12  1.000000e+00  1.714449e-12 #> z -3.372738e-11  1.941662e-11  1.714449e-12  1.000000e+00 P - t(P)                   # should be zero (P is symmetric) #>              t             x            y             z #> t 0.000000e+00 -8.881784e-16 0.000000e+00  0.000000e+00 #> x 8.881784e-16  0.000000e+00 5.551115e-17 -8.881784e-16 #> y 0.000000e+00 -5.551115e-17 0.000000e+00  0.000000e+00 #> z 0.000000e+00  8.881784e-16 0.000000e+00  0.000000e+00  ## First row of P should be a consistent 4-velocity: is.consistent.4vel(P[1,,drop=FALSE],give=TRUE) #>            t  #> -4.14575e-11"},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"Combines arguments recursively form vector three velocities four velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"","code":"# S3 method for 3vel c(...) # S3 method for 3cel c(...) # S3 method for 4vel c(...)"},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"... Vectors three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"Returns vector three-velocities four-velocities.    stored three- four- column matrices; row velocity. Names inherited behaviour cbind(),   c().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"function used extensively   inst/distributive_search.R. “c” celerity speed light, see sol().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/c.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine vectors of three-velocities and four-velocities into a single vector — c.3vel","text":"","code":"c(r3vel(3),r3vel(6,0.99)) #> A vector of three-velocities (speed of light = 1) #>                  x           y          z #>  [1,] -0.415744698  0.10026330  0.7865208 #>  [2,] -0.601648395  0.08066971 -0.7611560 #>  [3,] -0.551516839 -0.26349310 -0.7318576 #>  [4,]  0.047691916 -0.67512850 -0.7225144 #>  [5,] -0.816571206 -0.51167330 -0.2269403 #>  [6,]  0.350588473  0.51433867  0.7698334 #>  [7,] -0.006427608 -0.39984675  0.9056386 #>  [8,] -0.873190913 -0.27608763 -0.3760495 #>  [9,]  0.513227756 -0.51931608 -0.6685866"},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":null,"dir":"Reference","previous_headings":"","what":"Celerity and rapidity — celerity","title":"Celerity and rapidity — celerity","text":"celerity rapidity object (experimental functionality)","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Celerity and rapidity — celerity","text":"","code":"# S3 method for 3vel celerity(u) # S3 method for 4vel celerity(u) celerity_ur(d) # S3 method for 3vel rapidity(u) # S3 method for 4vel rapidity(u) rapidity_ur(d) as.3cel(x) cel_to_vel(x) vel_to_cel(x)"},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Celerity and rapidity — celerity","text":"u,x Speed: either vector speeds vector     three-velocities four-velocities d functions celerity_ur() rapidity_ur(),       deficit speed; speed light minus speed object","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Celerity and rapidity — celerity","text":"celerity corresponding speed \\(u\\) defined   \\(u\\gamma\\) rapidity   \\(c\\cdot\\mathrm{atanh}(u/c)\\). Functions celerity_ur() rapidity_ur() used   ultrarelativistic case speeds close speed   light.  argument d deficit, , \\(d=c-v\\)   \\(v\\) speed transformation.  Algebraically,   celerity_ur(c-v) == celerity(v), \\(d=1-v/c\\) small   result celerity_ur() accurate   celerity(). Things get bit sticky celerity rapidity \\(c\\neq   1\\).  guiding principle package give   celerity rapidity units \\(c\\), \\(u\\ll   c\\) three celerity(u),   rapidity(u) u approximately equal.  Note   carefully , contrast, \\(\\gamma\\) dimensionless.  Also   observe d functions celerity_ur()   rapidity_ur() units \\(c\\).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Celerity and rapidity — celerity","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/celerity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Celerity and rapidity — celerity","text":"","code":"u <- 0.1  # c=1 c(u,celerity(u),rapidity(u)) #> [1] 0.1000000 0.1005038 0.1003353  omgp <- 4.9e-24  # speed deficit of the Oh-My-God particle c(celerity_ur(omgp),rapidity_ur(omgp)) #> [1] 3.194383e+11 2.718298e+01   sol(299792458)                 # use SI units #> [1] 299792458 u <- 3e7  # ~0.1c c(u,celerity(u),rapidity(u)) #> [1] 30000000 30151345 30100745   snail <- 0.00275 c(snail,celerity(snail),rapidity(snail)) #> [1] 0.00275 0.00275 0.00275   omgp <- omgp*sol()  c(celerity_ur(omgp),rapidity_ur(omgp)) #> [1] 9.576519e+19 8.149252e+09   sol(1) #> [1] 1"},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":null,"dir":"Reference","previous_headings":"","what":"Failure of commutativity and associativity using visual plots — comm_fail","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"Relativistic addition three-velocities neither commutative associative, functions documented show visually.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"","code":"comm_fail1(u, v, bold=5, r=1) comm_fail2(u, v, bold=5, r=1) ass_fail(u, v, w, bold=5,r=1) my_seg(u,start=as.3vel(0), bold=5, ...)"},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"u,v,w,start Three velocities.  Arguments u w     single-element three velocities, argument v vector.  See     examples bold Integer specifying vector element drawn     bold r Radius dotted green circle, defaulting 1 (corresponding     \\(c=1\\)).  Use NA suppress plotting circle ... arguments, passed arrows()","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"functions called side-effect plotting diagram.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"vignette lorentz gives details   interpretation diagrams. Function my_seg() internal helper function.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/comm_fail.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Failure of commutativity and associativity using visual plots — comm_fail","text":"","code":"u <- as.3vel(c(0.4,0,0)) v <- seq(as.3vel(c(0.4,-0.2,0)), as.3vel(c(-0.3,0.9,0)),len=20) w <- as.3vel(c(0.8,-0.4,0))  comm_fail1(u=u, v=v)  comm_fail2(u=u, v=v)    ass_fail(u=u, v=v, w=w, bold=10)"},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Coordinate names for relativity — coordnames","title":"Coordinate names for relativity — coordnames","text":"Trivial function set coordinate names “t”, “x”, “y”, “z”.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coordinate names for relativity — coordnames","text":"","code":"coordnames(...) flob(x)"},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coordinate names for relativity — coordnames","text":"... arguments, currently ignored x matrix","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coordinate names for relativity — coordnames","text":"Function coordnames() simply returns character string   c(\"t\",\"x\",\"y\",\"z\").  may overwritten.   Function flob() sets row columnnames \\(4\\times     4\\) matrix coordnames().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coordinate names for relativity — coordnames","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Coordinate names for relativity — coordnames","text":"anyone can think better name flob() let know.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/coordnames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coordinate names for relativity — coordnames","text":"","code":"coordnames() #> [1] \"t\" \"x\" \"y\" \"z\"  flob(diag(3)) #>   x y z #> x 1 0 0 #> y 0 1 0 #> z 0 0 1 flob(matrix(1,4,4)) #>   t x y z #> t 1 1 1 1 #> x 1 1 1 1 #> y 1 1 1 1 #> z 1 1 1 1  ## You can change the names if you wish: coordnames <- function(x){letters[1:4]} flob(outer(1:4,1:4)) #>   t x  y  z #> t 1 2  3  4 #> x 2 4  6  8 #> y 3 6  9 12 #> z 4 8 12 16"},{"path":"https://robinhankin.github.io/lorentz/reference/cosines.html","id":null,"dir":"Reference","previous_headings":"","what":"Direction cosines — cosines","title":"Direction cosines — cosines","text":"Given vector three-velocities, returns direction cosines","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/cosines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Direction cosines — cosines","text":"","code":"cosines(u, drop = TRUE)"},{"path":"https://robinhankin.github.io/lorentz/reference/cosines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Direction cosines — cosines","text":"u vector three-velocities drop Boolean, default TRUE meaning coerce return     value one-row matrix vector, FALSE meaning     consistently return matrix","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/cosines.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Direction cosines — cosines","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/cosines.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Direction cosines — cosines","text":"","code":"cosines(r3vel(7)) #>               x           y          z #> [1,]  0.9691627  0.22520722  0.1000269 #> [2,]  0.3613739  0.35737305  0.8612162 #> [3,]  0.1053756 -0.90498295  0.4121915 #> [4,] -0.0567509 -0.50939198 -0.8586613 #> [5,] -0.8081941 -0.44932233  0.3806990 #> [6,]  0.8072650  0.04276198  0.5886380 #> [7,] -0.4444298 -0.15105222  0.8829866   cosines(r3vel(1),drop=TRUE) #>          x          y          z  #> -0.3883539 -0.8319203 -0.3963456  cosines(r3vel(1),drop=FALSE) #>               x         y         z #> [1,] -0.5536599 0.6948522 0.4589566"},{"path":"https://robinhankin.github.io/lorentz/reference/galileo.html","id":null,"dir":"Reference","previous_headings":"","what":"Classical mechanics; Newtonian approximation; infinite speed of light — galileo","title":"Classical mechanics; Newtonian approximation; infinite speed of light — galileo","text":"Lorentz transforms reduce classical limit, Galilean transforms, speeds low compared \\(c\\).  Package idiom working classical framework use infinite speed light: sol(Inf).  show examples .","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/galileo.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Classical mechanics; Newtonian approximation; infinite speed of light — galileo","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/galileo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classical mechanics; Newtonian approximation; infinite speed of light — galileo","text":"","code":"sol(Inf) #> [1] Inf boost(as.3vel(1:3)) #>    t x y z #> t  1 0 0 0 #> x -1 1 0 0 #> y -2 0 1 0 #> z -3 0 0 1 as.3vel(1:3) + as.3vel(c(-1,4,5))     # classical velocity addition #> A vector of three-velocities (speed of light = Inf) #>      x y z #> [1,] 0 6 8 rot(as.3vel(1:3),as.3vel(c(-4,5,2)))  # identity matrix #>   x y z #> x 1 0 0 #> y 0 1 0 #> z 0 0 1   B <- boost(as.3vel(1:3)) orthog(B) %*% pureboost(B)  # should be B #>       t x y z #> [1,]  1 0 0 0 #> [2,] -1 1 0 0 #> [3,] -2 0 1 0 #> [4,] -3 0 0 1  sol(1) #> [1] 1"},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Gamma correction — gam","title":"Gamma correction — gam","text":"Lorentz gamma correction term special relativity","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gamma correction — gam","text":"","code":"# S3 method for 3vel speed(u) # S3 method for 4vel speed(u) speedsquared(u) gam(u) gamm1(u) # S3 method for 3vel gam(u) # S3 method for 3cel gam(u) # S3 method for 4vel gam(u) # S3 method for 3vel gamm1(u) # S3 method for 4vel gamm1(u) gam_ur(d)"},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gamma correction — gam","text":"u Speed: either vector speeds vector     three-velocities four-velocities d function gam_ur(), deficit speed; speed light       minus speed object","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gamma correction — gam","text":"Function speed(u) returns speed 3vel object   4vel object. Function gam(u) returns Lorentz factor   $$\\frac{1}{\\sqrt{1-\\mathbf{u}\\cdot\\mathbf{u}/c^2}}$$ Function gamm1(u) returns Lorentz factor minus 1, useful   slow speeds larger accuracy needed (much like   expm1()); see R idiom, type “gamm1.3vel”   commandline.  Function gamm1() intended work   3vel objects speeds.  function take 4-velocity,   recommended accuracy lost (return   time component 4-velocity minus 1). Function gam_ur() used ultrarelativistic case   speeds close speed light (function named   “gamma, ultrarelativistic”).  argument d   deficit, , \\(c-v\\) \\(v\\) speed   transformation.  Algebraically, gam_ur(c-v) == gam(v),   d small compared c result accurate. Function speedsquared(u) returns square speed   3vel object.  Use avoid taking needless square root.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gamma correction — gam","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gamma correction — gam","text":"","code":"gam(seq(from=0,by=0.1,len=10)) #>  [1] 1.000000 1.005038 1.020621 1.048285 1.091089 1.154701 1.250000 1.400280 #>  [9] 1.666667 2.294157 gam(r3vel(6,0.7)) #> [1] 1.40028 1.40028 1.40028 1.40028 1.40028 1.40028   x <- as.3vel(c(0.1,0.4,0.5)) speed(x) #> [1] 0.6480741  gam(speed(x))  # works, but slow and inaccurate #> [1] 1.313064 gam(x)         # recommended: avoids needless coercion #> [1] 1.313064    ## Use SI units and deal with terrestrial speeds.  Use gamm1() for this. sol(299792458) #> [1] 299792458 sound <- 343 # speed of sound in SI gam(sound) #> [1] 1 gam(sound)-1   #> [1] 6.545875e-13 gamm1(sound)   # gamm1() gives much higher precision #> [1] 6.545108e-13  snail <- as.3vel(c(0.00275,0,0)) # even the world's fastest snail... gamm1(snail)                     # ...has only a small relativistic correction #> [1] 4.207208e-23   ## For the ultrarelativistic case of speeds very close to the speed of ## light, use gam_ur():  sol(1)           # revert to relativistic units #> [1] 1  gam(0.99) - gam_ur(0.01) # zero to numerical accuracy #> [1] -4.440892e-15  omgp <- 4.9e-24  # speed deficit of the Oh-My-God particle gam(1-omgp)      # numeric overflow #> [1] Inf gam_ur(omgp)     # large but finite #> [1] 319438282500"},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":null,"dir":"Reference","previous_headings":"","what":"Gyr function — gyr","title":"Gyr function — gyr","text":"Relativistic addition three velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gyr function — gyr","text":"","code":"gyr(u, v, x) gyr.a(u, v, x) gyrfun(u, v)"},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gyr function — gyr","text":"u,v,x Three-velocities, objects class 3vel","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gyr function — gyr","text":"Function  gyr(u,v,x) returns three-vector   \\(\\mathrm{gyr}[u,v]x\\). Function gyrfun(u,v) returns function returns   three-vector; see examples. speed light (1 default) used directly   functions; set sol().","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gyr function — gyr","text":"Ungar 2006. “Thomas precession: kinematic   effect algebra Einstein's velocity addition law.  Comments   ‘Deriving relativistic momentum energy: II.     Three-dimensional case’”. European Journal Physics,   27:L17-L20. Sbitneva 2001. “Nonassociative geometry special relativity”. International Journal Theoretical Physics, volume 40, number 1,   pages 359--362","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gyr function — gyr","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Gyr function — gyr","text":"Function gyr() slightly faster gyr.(),   included pedagogical reasons. Function gyr() simply add3(neg3(add3(u,v)),add3(u,add3(v,x))) function gyr.() uses slower transparent   idiom -(u+v) + (u+(v+x))","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/gyr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gyr function — gyr","text":"","code":"u <- r3vel(10) v <- r3vel(10) w <- r3vel(10)  x <- as.3vel(c(0.4,0.1,-0.5)) y <- as.3vel(c(0.1,0.2,-0.7)) z <- as.3vel(c(0.2,0.3,-0.1))   gyr(u,v,x)  # gyr[u,v]x #> A vector of three-velocities (speed of light = 1) #>               x             y          z #>  [1,] 0.1771184  0.2735626698 -0.5601719 #>  [2,] 0.3663964  0.1900280524 -0.4996429 #>  [3,] 0.3350914  0.2885550731 -0.4737612 #>  [4,] 0.0432846  0.0342772778 -0.6457178 #>  [5,] 0.5686156 -0.1768786418 -0.2557152 #>  [6,] 0.5304323 -0.1446688952 -0.3430926 #>  [7,] 0.1076404  0.0969558028 -0.6316749 #>  [8,] 0.4582328  0.0006046773 -0.4582820 #>  [9,] 0.5199783 -0.3036368446 -0.2396399 #> [10,] 0.3621008 -0.1998982906 -0.4989225  f <- gyrfun(u,v) g <- gyrfun(v,u)  f(x) #> A vector of three-velocities (speed of light = 1) #>               x             y          z #>  [1,] 0.1771184  0.2735626698 -0.5601719 #>  [2,] 0.3663964  0.1900280524 -0.4996429 #>  [3,] 0.3350914  0.2885550731 -0.4737612 #>  [4,] 0.0432846  0.0342772778 -0.6457178 #>  [5,] 0.5686156 -0.1768786418 -0.2557152 #>  [6,] 0.5304323 -0.1446688952 -0.3430926 #>  [7,] 0.1076404  0.0969558028 -0.6316749 #>  [8,] 0.4582328  0.0006046773 -0.4582820 #>  [9,] 0.5199783 -0.3036368446 -0.2396399 #> [10,] 0.3621008 -0.1998982906 -0.4989225 f(r3vel(10)) #> A vector of three-velocities (speed of light = 1) #>                  x           y           z #>  [1,]  0.774040968 -0.35373914 -0.18639891 #>  [2,] -0.004843351 -0.27022647  0.72341884 #>  [3,]  0.832677528 -0.17331614 -0.39173220 #>  [4,] -0.207754446 -0.27592101  0.57199358 #>  [5,] -0.057751108 -0.65977173  0.06731880 #>  [6,] -0.240525027  0.22833222  0.20158538 #>  [7,]  0.064670853 -0.67423008 -0.64191814 #>  [8,]  0.549869911  0.06483912  0.49835869 #>  [9,]  0.801218236  0.01343356  0.01492428 #> [10,]  0.482222378 -0.57760639 -0.26883529  f(g(x)) - x              # zero, by eqn 9 #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,]  6.699622e-15 -8.697545e-15  4.929007e-15 #>  [2,]  2.153450e-16  6.879076e-16  0.000000e+00 #>  [3,]  1.100652e-15  8.793253e-16 -1.722760e-15 #>  [4,] -4.785444e-16 -6.579986e-17  2.416649e-15 #>  [5,]  1.794542e-15  2.033814e-15 -5.240061e-15 #>  [6,] -6.699622e-16  7.776347e-16  1.196361e-16 #>  [7,]  2.392722e-17 -4.785444e-17  5.742533e-16 #>  [8,]  3.349811e-16  4.785444e-17 -9.331616e-16 #>  [9,] -2.560213e-15 -9.259834e-15  8.805217e-15 #> [10,] -7.178166e-17  1.585178e-15 -5.024716e-16 g(f(x)) - x              # zero, by eqn 9 #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,]  1.028870e-15 -9.989614e-16 -9.570888e-17 #>  [2,]  5.263988e-16  3.469447e-16 -2.392722e-16 #>  [3,] -4.474390e-15  1.507415e-15  7.178166e-16 #>  [4,]  8.374527e-16  2.093632e-16 -1.124579e-15 #>  [5,] -5.048643e-15  3.840319e-15 -3.349811e-15 #>  [6,] -4.546172e-16 -1.136543e-16  1.004943e-15 #>  [7,] -1.674905e-16 -2.572176e-16  3.349811e-16 #>  [8,]  7.178166e-17  5.383625e-17  2.392722e-16 #>  [9,]  9.762306e-15 -4.629917e-15  1.315997e-15 #> [10,]  1.603124e-15 -2.661903e-15 -2.847339e-15 (x+y) - f(y+x)           # zero by eqn 10 #> A vector of three-velocities (speed of light = 1) #>                 x            y           z #>  [1,]  0.81766549 -0.086857696 -0.18048373 #>  [2,]  0.43336199 -0.002021549  0.08771057 #>  [3,]  0.52888982 -0.343928787 -0.10404877 #>  [4,]  0.85780241  0.188569750 -0.30756131 #>  [5,] -0.27285511  0.568410154 -0.53061760 #>  [6,] -0.19074389  0.618991804 -0.33087180 #>  [7,]  0.86095136  0.100039875 -0.23995752 #>  [8,]  0.03822235  0.251781587  0.03793728 #>  [9,] -0.04971639  0.709511827 -0.56002551 #> [10,]  0.40128021  0.716806938 -0.20190871 (u+(v+w)) - ((u+v)+f(w)) # zero by eqn 11 #> A vector of three-velocities (speed of light = 1) #>                   x             y             z #>  [1,]  7.314624e-14 -3.657312e-14  1.828656e-14 #>  [2,] -1.191338e-15 -2.978344e-16 -2.978344e-16 #>  [3,]  0.000000e+00  0.000000e+00 -1.969634e-17 #>  [4,] -3.528078e-16  1.470033e-16  4.704104e-16 #>  [5,]  0.000000e+00  1.208483e-14 -2.416965e-14 #>  [6,] -1.073371e-15  5.366856e-16  6.708571e-17 #>  [7,]  5.522374e-14 -1.104475e-13  1.104475e-13 #>  [8,]  3.405187e-16 -6.810375e-16  3.405187e-16 #>  [9,]  0.000000e+00  9.116478e-15  0.000000e+00 #> [10,]  0.000000e+00 -2.516764e-15  0.000000e+00   # Following taken from Sbitneva 2001:  rbind(x+(y+(x+z))  ,   (x+(y+x))+z)   # left Bol property #>           [,1]      [,2]       [,3] #> [1,] 0.4894115 0.2314344 -0.8300767 #> [2,] 0.4894115 0.2314344 -0.8300767 rbind((x+y)+(x+y)  ,   x+(y+(y+x)))   # left Bruck property #>          [,1]     [,2]       [,3] #> [1,] 0.432766 0.209512 -0.8738679 #> [2,] 0.432766 0.209512 -0.8738679   sol(299792458)   # speed of light in SI #> [1] 299792458 as.3vel(c(1000,3000,1000)) + as.3vel(c(1000,3000,1000)) #> A vector of three-velocities (speed of light = 299792458) #>         x    y    z #> [1,] 2000 6000 2000 ## should be close to Galilean result  sol(1)   # revert to default c=1 #> [1] 1"},{"path":"https://robinhankin.github.io/lorentz/reference/lorentz-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The Lorentz Transform in Relativistic Physics — lorentz-package","title":"The Lorentz Transform in Relativistic Physics — lorentz-package","text":"Lorentz transform special relativity; also     gyrogroup structure three-velocities.  Performs active     passive transforms ability use units     speed light unity.  Includes experimental     functionality celerity rapidity.  general relativity,     see 'schwarzschild' package.  cite lorentz package     publications please use Hankin (2022)     <doi:10.48550/ARXIV.2212.07005>.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/lorentz-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Lorentz Transform in Relativistic Physics — lorentz-package","text":"DESCRIPTION file: package yet installed build time.   Index:  package yet installed build time.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/lorentz-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The Lorentz Transform in Relativistic Physics — lorentz-package","text":"NA Maintainer: Robin K. S. Hankin <hankin.robin@gmail.com>","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/lorentz-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Lorentz Transform in Relativistic Physics — lorentz-package","text":"Ungar 2006. “Thomas precession: kinematic   effect...”. European Journal Physics, 27:L17-L20. https://www.youtube.com/watch?v=9Y9CxiukURw&index=68&list=PL9_n3Tqzq9iWtgD8POJFdnVUCZ_zw6OiB","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/lorentz-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Lorentz Transform in Relativistic Physics — lorentz-package","text":"","code":"u <- as.3vel(c(0.3,0.6,-0.1))  # u is a three-velocity gam(u)                         # relativistic gamma term for u #> [1] 1.360828 U <- as.4vel(u)                # U is a four-velocity B1 <- boost(u)                 # B1 is the Lorentz transform matrix for u B1 %*% c(1,0,0,0)              # Lorentz transform of zero 4-velocity (=-u) #>         [,1] #> t  1.3608276 #> x -0.4082483 #> y -0.8164966 #> z  0.1360828  B2 <- boost(as.3vel(c(-0.1,0.8,0.3)))   B3 <- boost(as.3vel(c(-0.1,0.1,0.9)))  # more boosts  Bi <- B1 %*% B2  # Bi is the boost for successive Lorentz transforms   pureboost(Bi)      # Decompose Bi into a pure boost... #>             t           x           y           z #> t  3.78969964 -0.06713162 -3.54542995 -0.88726725 #> x -0.06713162  1.00094091  0.04969215  0.01243579 #> y -3.54542995  0.04969215  3.62439704  0.65677268 #> z -0.88726725  0.01243579  0.65677268  1.16436170 orthog(Bi)         # and an orthogonal matrix #>               t             x             y             z #> t  1.000000e+00 -1.046611e-14 -5.410925e-13 -1.350410e-13 #> x -1.236185e-13  9.794943e-01  1.895365e-01  6.831470e-02 #> y -5.484482e-13 -1.983854e-01  9.664761e-01  1.629943e-01 #> z -3.897417e-14 -3.513115e-02 -1.732047e-01  9.842591e-01  Bj <- B2 %*% B1    # B1 and B2 do not commute...  (B1 %*% B2) %*% B3  #>            t          x          y          z #> t  11.971728  1.0488714 -4.6614329 -10.931294 #> x  -2.357261  0.7672474  1.0039324   2.227135 #> y -11.332721 -1.2028617  4.6544280  10.311158 #> z  -2.887046 -0.2541382  0.2395334   3.035305 B1 %*% (B2 %*% B3)    # ...but composition *is* associative #>            t          x          y          z #> t  11.971728  1.0488714 -4.6614329 -10.931294 #> x  -2.357261  0.7672474  1.0039324   2.227135 #> y -11.332721 -1.2028617  4.6544280  10.311158 #> z  -2.887046 -0.2541382  0.2395334   3.035305    ## Three velocities and the gyrogroup  ## Create some random three-velocities:  u <- r3vel(10) v <- r3vel(10) w <- r3vel(10)  u+v #> A vector of three-velocities (speed of light = 1) #>                 x           y          z #>  [1,] -0.14012069 -0.62601780  0.6615552 #>  [2,]  0.03221912  0.80830918 -0.1790383 #>  [3,] -0.51656237  0.75619466 -0.3864460 #>  [4,]  0.02018581 -0.68080689 -0.6230009 #>  [5,]  0.28496129  0.51928238 -0.8055608 #>  [6,] -0.77433707 -0.36292028  0.4997554 #>  [7,] -0.21713576 -0.51391738  0.6332958 #>  [8,] -0.96249693  0.25344854  0.0534315 #>  [9,] -0.53101214  0.08288555  0.8213696 #> [10,] -0.16401754 -0.96046223 -0.1704456 v+u        # Three-velocity addition is not commutative... #> A vector of three-velocities (speed of light = 1) #>                 x           y           z #>  [1,] -0.06316762 -0.77064871  0.50129613 #>  [2,]  0.18056196  0.68120864 -0.43567038 #>  [3,] -0.32084315  0.28889549 -0.89532490 #>  [4,] -0.33723700 -0.75672746 -0.40702625 #>  [5,]  0.98925519 -0.07673528 -0.12357687 #>  [6,] -0.78620661 -0.03329154  0.60152751 #>  [7,] -0.33490797 -0.43338375  0.64213529 #>  [8,] -0.68779558  0.71917857 -0.05666438 #>  [9,] -0.26064390 -0.16716574  0.93145707 #> [10,] -0.82509649 -0.54141501  0.06728077  u+(v+w)   # ... nor associative #> A vector of three-velocities (speed of light = 1) #>                x           y           z #>  [1,]  0.1113195 -0.83587689  0.01351084 #>  [2,]  0.2023680  0.96209896 -0.15777599 #>  [3,] -0.5443017  0.76784713 -0.31187046 #>  [4,]  0.1203930 -0.63871732 -0.75023903 #>  [5,]  0.2878327  0.51184303 -0.80941004 #>  [6,] -0.6705080 -0.42475047  0.58340998 #>  [7,]  0.3457588 -0.48163601  0.47578638 #>  [8,] -0.9607838  0.27279415  0.02222649 #>  [9,] -0.4416477  0.01992503  0.88601495 #> [10,] -0.1982400 -0.91900822 -0.31324931 (u+v)+w  #> A vector of three-velocities (speed of light = 1) #>                 x            y           z #>  [1,]  0.11652737 -0.621716988 -0.09696920 #>  [2,]  0.26092544  0.929098691 -0.24350555 #>  [3,] -0.53728852  0.770894246 -0.33212223 #>  [4,]  0.04709357 -0.682168700 -0.72162032 #>  [5,]  0.29147239  0.505599474 -0.81199527 #>  [6,] -0.68064194 -0.447343973  0.56067697 #>  [7,]  0.32714930 -0.547996789  0.51736036 #>  [8,] -0.95676426  0.285196758  0.01270503 #>  [9,] -0.41274422  0.005694978  0.89171483 #> [10,] -0.15023309 -0.932207873 -0.30744832"},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":null,"dir":"Reference","previous_headings":"","what":"Photons — photon","title":"Photons — photon","text":"Various functionality deal 4-momentum photon","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Photons — photon","text":"","code":"is.consistent.nullvec(N,TOL=1e-10) as.photon(x,E=1)"},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Photons — photon","text":"N Four-momentum tested nullness TOL tolerance x Vector three-velocities E Energy, scalar","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Photons — photon","text":"Returns four-momentum photon.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Photons — photon","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/photon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Photons — photon","text":"","code":"## A bunch of photons all approximately parallel to the x-axis: as.photon(as.3vel(cbind(0.9,runif(10)/1000,runif(10)/1000))) #>       E       p_x          p_y          p_z #>  [1,] 1 0.9999999 0.0001367530 0.0003977735 #>  [2,] 1 0.9999989 0.0010684742 0.0010028358 #>  [3,] 1 0.9999995 0.0009514986 0.0001333210 #>  [4,] 1 0.9999999 0.0000494103 0.0004958587 #>  [5,] 1 0.9999994 0.0010511556 0.0003988674 #>  [6,] 1 0.9999997 0.0005127021 0.0005121175 #>  [7,] 1 0.9999998 0.0002892654 0.0005431666 #>  [8,] 1 0.9999996 0.0002753430 0.0008561776 #>  [9,] 1 0.9999997 0.0006589955 0.0004016151 #> [10,] 1 0.9999998 0.0001285912 0.0005529472   ## mirror ball: jj <- matrix(rnorm(30),10,3) disco <- sweep(matrix(rnorm(30),10,3),1,sqrt(rowSums(jj^2)),`/`) p <- as.photon(c(1,0,0)) reflect(p,disco) #>   E         p_x        p_y         p_z #> x 1  0.78582711  0.1468142 -0.60076731 #> x 1  0.85990585 -0.4851562 -0.15869895 #> x 1  0.96058840 -0.2282072 -0.15871794 #> x 1  0.77581045 -0.6130671  0.14922103 #> x 1 -0.01596423 -0.7255936 -0.68793825 #> x 1  0.98450100 -0.1570580  0.07804212 #> x 1 -0.89020908  0.4379610 -0.12537123 #> x 1  0.89879332  0.2926319  0.32640032 #> x 1  0.75629556  0.4257562 -0.49673802 #> x 1  0.35629511 -0.8750320 -0.32767789  table(reflect(p,disco)[,2]>0) # should be TRUE with probability sqrt(0.5) #>  #> FALSE  TRUE  #>     2     8   ## relativistic  disco; mirror ball moves at 0.5c:  B <- boost(as.3vel(c(0.5,0,0))) p |> tcrossprod(B) |> reflect(disco) |> tcrossprod(solve(B)) #>           t          x           y           z #> x 0.9286090  0.8572181  0.08476320 -0.34685317 #> x 0.9533019  0.9066039 -0.28010509 -0.09162488 #> x 0.9868628  0.9737256 -0.13175550 -0.09163585 #> x 0.9252702  0.8505403 -0.35395444  0.08615280 #> x 0.6613453  0.3226905 -0.41892168 -0.39718133 #> x 0.9948337  0.9896673 -0.09067747  0.04505764 #> x 0.3699303 -0.2601394  0.25285690 -0.07238311 #> x 0.9662644  0.9325289  0.16895108  0.18844731 #> x 0.9187652  0.8375304  0.24581047 -0.28679183 #> x 0.7854317  0.5708634 -0.50519996 -0.18918492"},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print methods for three-velocities and four-velocities — print.3vel","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"Print methods three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"","code":"# S3 method for 3vel print(x, ...) # S3 method for 3cel print(x, ...) # S3 method for 4vel print(x, ...) # S3 method for 4mom print(x, ...)"},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"x Vector three-velocities ... arguments, currently ignored","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"Returns vector three-velocities","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/print.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print methods for three-velocities and four-velocities — print.3vel","text":"","code":"r3vel(10) #> A vector of three-velocities (speed of light = 1) #>                 x           y          z #>  [1,]  0.17286638  0.19145746 -0.5846327 #>  [2,]  0.41460845  0.58435364  0.4964753 #>  [3,] -0.27867624  0.70101569  0.2401100 #>  [4,]  0.35311599 -0.01024694 -0.4840603 #>  [5,]  0.08723549 -0.20803503  0.5051114 #>  [6,] -0.74707531 -0.47360648  0.1696788 #>  [7,] -0.56658914 -0.19374124 -0.3299985 #>  [8,] -0.41084093 -0.60755277  0.5908122 #>  [9,]  0.11594281 -0.25098834  0.6268252 #> [10,]  0.19801285  0.14598166  0.2665090"},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":null,"dir":"Reference","previous_headings":"","what":"Random relativstic velocities — r3vel","title":"Random relativstic velocities — r3vel","text":"Generates random three-velocities four-velocities, optionally specifiying magnitude","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random relativstic velocities — r3vel","text":"","code":"r3vel(n=7, r = NA) r4vel(...) rboost(r = NA)"},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random relativstic velocities — r3vel","text":"n Number three- four- velocities generate r Absolute value three-velocities, default     NA meaning sample uniformly unit ball ... Arguments passed r3vel()","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random relativstic velocities — r3vel","text":"Function r3vel() returns random three-velocity.  Function   r4vel() convenience wrapper .4vel(r3vel()). Function rboost() returns random \\(4\\times 4\\) Lorentz   boost matrix, drawn connected component.  given   r=0, transform corresponding random rotation   returned.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random relativstic velocities — r3vel","text":"Returns vector three- four- velocities.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random relativstic velocities — r3vel","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Random relativstic velocities — r3vel","text":"speed light infinite, functions require specified   argument r. entirely trivial sample uniformly unit ball   unit sphere, hard either.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/r3vel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random relativstic velocities — r3vel","text":"","code":"r3vel() #> A vector of three-velocities (speed of light = 1) #>               x            y          z #> [1,]  0.7822484  0.002840634 -0.3830851 #> [2,]  0.3459759  0.045294711  0.6798154 #> [3,] -0.1229432 -0.319915352 -0.9076486 #> [4,]  0.8134368  0.001658398  0.3454321 #> [5,] -0.2389068 -0.410108086  0.1213934 #> [6,] -0.6842307  0.041435894  0.3329698 #> [7,]  0.2596908 -0.591858263  0.4228943  a <- r3vel(10000) b <- r3vel(1000,0.8) u <- as.3vel(c(0,0,0.9))  pairs(unclass(u+a),asp=1)  pairs(unclass(a+u),asp=1)   is.consistent.boost(rboost()) #> [1] TRUE  sol(299792458)    # switch to SI units #> [1] 299792458 sound <- 343      # speed of sound in metres per second r3vel(100,343)    # random 3-velocities with speed = 343 m/s #> A vector of three-velocities (speed of light = 299792458) #>                  x           y           z #>   [1,] -323.679623  -12.321104 -112.821504 #>   [2,] -233.758593 -225.054309 -111.159697 #>   [3,] -145.463770 -136.649547 -278.955540 #>   [4,]  -35.683845  -13.138364 -340.885680 #>   [5,]  119.037276 -311.779259  -79.201142 #>   [6,] -199.220438 -277.719655   28.844587 #>   [7,] -218.388665 -258.846015   54.351923 #>   [8,]  182.810751  181.467886  226.492021 #>   [9,]   63.764543 -314.594456 -120.885942 #>  [10,]  267.946800 -101.239027 -188.690677 #>  [11,] -263.176242 -181.126459 -124.821759 #>  [12,]   78.828377 -185.060658  277.826636 #>  [13,]  -64.924260   90.084623 -324.528275 #>  [14,]  118.012146   64.892417 -315.453812 #>  [15,] -234.143662  189.813070  163.697110 #>  [16,]   76.312738   74.211088  326.064534 #>  [17,]   29.370649 -336.361397  -60.393508 #>  [18,]   -3.784452 -256.256948 -227.962836 #>  [19,]    7.763676  103.504963 -326.918106 #>  [20,]   -8.383734   46.256484  339.763227 #>  [21,]  134.401778  -98.763811  299.717987 #>  [22,] -323.829986  -82.878521  -76.904428 #>  [23,]  274.796331  184.152262   90.685835 #>  [24,] -288.028593  163.116916   89.896614 #>  [25,]  165.956918 -299.736348   16.291820 #>  [26,] -292.138869  -60.913339 -169.095968 #>  [27,] -130.471439  -55.546670  312.315179 #>  [28,] -124.015089  206.974953 -243.783975 #>  [29,]   32.944983  -89.870267  329.373592 #>  [30,]  116.602893 -270.525137  175.695520 #>  [31,]  278.003561  -68.112308 -189.007231 #>  [32,]   -4.541805 -298.473732  168.943195 #>  [33,] -239.062759  245.294447   18.128195 #>  [34,] -259.612850  163.349117  153.516234 #>  [35,] -175.418579  169.725097 -240.978658 #>  [36,] -155.236338  305.288864  -18.691949 #>  [37,] -219.080212 -135.660084  226.382867 #>  [38,]   97.302422  322.482184   64.703010 #>  [39,] -120.551438 -172.008819 -271.162898 #>  [40,]  -83.696914 -296.349589 -151.065376 #>  [41,]  -94.836512 -313.207445  102.743042 #>  [42,] -141.346078  257.357986 -177.305254 #>  [43,]  -67.704124   35.594580 -334.362345 #>  [44,] -236.624962  -11.246352 -248.054725 #>  [45,]  118.605751 -291.869297  135.624442 #>  [46,]  -85.820473 -263.670693  201.895052 #>  [47,]  -56.207063 -139.140284 -308.431107 #>  [48,] -209.313356 -271.716449   -2.662798 #>  [49,]  -59.324370   44.279367  334.916343 #>  [50,] -211.694342 -235.214636  132.319994 #>  [51,]  253.245203 -191.391770 -129.942518 #>  [52,] -279.819615 -108.991561 -165.743243 #>  [53,]  222.481229  260.818018   11.183210 #>  [54,] -191.794860 -118.261378 -258.607769 #>  [55,] -147.150674 -100.817632 -292.970108 #>  [56,]   84.626799  228.450038  241.449550 #>  [57,]  210.663647  127.500326  238.774988 #>  [58,]  173.952578 -264.015714  132.985726 #>  [59,] -315.880722  -45.416472 -125.720776 #>  [60,] -214.640811  187.410310  190.933753 #>  [61,]  282.605828  -91.722189  171.376738 #>  [62,]   48.851097  313.659793 -129.923456 #>  [63,]  -50.920422  273.643023  200.438535 #>  [64,]  316.255108 -103.945320   82.626129 #>  [65,]  159.861671 -113.052999  281.624334 #>  [66,] -318.464608 -127.267013   -5.692160 #>  [67,] -120.571654  299.447262  115.943147 #>  [68,]  324.971813  109.555652    6.315043 #>  [69,]  145.754948  303.611015   64.998820 #>  [70,] -183.417018 -273.512703   95.906198 #>  [71,]    7.872660 -130.236792 -317.215068 #>  [72,]  260.315491 -116.073037 -190.819011 #>  [73,] -128.972886 -283.724919  143.231160 #>  [74,]   -8.831723 -342.879954   -2.082688 #>  [75,]  -26.629704   55.197378  337.480530 #>  [76,]  -26.510380  310.442677 -143.427835 #>  [77,]  308.574991 -127.515254   78.551478 #>  [78,]  318.254773  114.220970   57.588794 #>  [79,] -249.463924  198.579097  126.424258 #>  [80,]   85.315566    7.147149 -332.143301 #>  [81,] -177.785913  289.479438   47.358465 #>  [82,] -141.369714 -312.120967  -15.623895 #>  [83,]  284.951826 -189.047337   26.693842 #>  [84,]  261.897055  217.979268   39.293398 #>  [85,] -289.827939  -77.371985  166.319998 #>  [86,]  334.346653  -47.691352  -59.890323 #>  [87,] -316.293829   82.047476 -104.285306 #>  [88,] -248.118097 -164.575163 -170.298050 #>  [89,]  -60.109930  -60.561150 -332.217012 #>  [90,]  -90.015314 -169.524340 -284.267025 #>  [91,]   46.258965  199.461247 -275.180521 #>  [92,]  -62.206460  -85.594507 -326.271262 #>  [93,]  198.539119 -239.259820 -144.865305 #>  [94,] -284.750665 -157.367622 -108.634664 #>  [95,]  157.019755 -174.786456  249.886957 #>  [96,]  296.264209  -33.621767 -169.546735 #>  [97,] -150.800901  142.033792 -273.376097 #>  [98,]  283.509532  140.468046 -132.438943 #>  [99,]  -87.095790  -86.425323  320.302961 #> [100,] -185.732161  266.170421 -110.931833  sol(1)   # return to default c=1 #> [1] 1"},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":null,"dir":"Reference","previous_headings":"","what":"Mirrors — reflect","title":"Mirrors — reflect","text":"Plane mirrors special relativity","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mirrors — reflect","text":"","code":"reflect(P,m,ref=1)"},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mirrors — reflect","text":"P Vector four-momenta m Orientation mirror, expressed three-vector ref Coefficient reflectivity mirror","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mirrors — reflect","text":"Takes four-momentum returns four-momentum reflection.   handle objects photons.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mirrors — reflect","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Mirrors — reflect","text":"four-momenta measured rest frame mirror,   easy reflect moving mirrors; see examples. However, note ref argument designed work   photons , conceptually percentage photons   reflected absorbed mirror.  ref less   unity, odd results given four momenta nonzero restmass   objects.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/reflect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mirrors — reflect","text":"","code":"## We will reflect some photons from an oblique mirror moving at half ## the speed of light.  ## First create 'A', a bunch of photons all moving roughly along the x-axis: A <- as.photon(as.3vel(cbind(0.9,runif(10)/1000,runif(10)/1000)))  ## Now create 'm', a mirror oriented perpendicular to c(1,1,1): m <- c(1,1,1)  ## Reflect the photons in the mirror: reflect(A,m) #>       E       p_x        p_y        p_z #>  [1,] 1 0.3324283 -0.6672908 -0.6664942 #>  [2,] 1 0.3325610 -0.6664823 -0.6672365 #>  [3,] 1 0.3326448 -0.6669767 -0.6667004 #>  [4,] 1 0.3331629 -0.6666433 -0.6667752 #>  [5,] 1 0.3323887 -0.6670774 -0.6667275 #>  [6,] 1 0.3319579 -0.6669455 -0.6670740 #>  [7,] 1 0.3326090 -0.6668510 -0.6668440 #>  [8,] 1 0.3327217 -0.6667668 -0.6668720 #>  [9,] 1 0.3331423 -0.6667095 -0.6667193 #> [10,] 1 0.3328581 -0.6667578 -0.6668130  ## Reflect the photons in a series of mirrors: A |> reflect(m) |> reflect(1:3) |> reflect(3:1)  #>       E        p_x        p_y       p_z #>  [1,] 1 -0.6463067 -0.7480406 0.1507411 #>  [2,] 1 -0.6469435 -0.7476543 0.1499242 #>  [3,] 1 -0.6464434 -0.7480051 0.1503311 #>  [4,] 1 -0.6463942 -0.7481672 0.1497340 #>  [5,] 1 -0.6465251 -0.7478868 0.1505673 #>  [6,] 1 -0.6469329 -0.7475098 0.1506881 #>  [7,] 1 -0.6465803 -0.7479058 0.1502358 #>  [8,] 1 -0.6465801 -0.7479342 0.1500951 #>  [9,] 1 -0.6463486 -0.7481921 0.1498064 #> [10,] 1 -0.6464966 -0.7480235 0.1500103   ## To reflect from a moving mirror we need to transform to a frame in ## which the mirror is at rest, then transform back to the original ## frame.  First create B, a boost representing the mirror's movement ## along the x-axis at speed c/2:  B <- boost(as.3vel(c(0.5,0,0)))   ## Transform to the mirror's rest frame: A %*% t(B)     #>               t         x            y            z #>  [1,] 0.5773506 0.5773496 0.0002803115 1.076901e-03 #>  [2,] 0.5773505 0.5773497 0.0009561966 2.020699e-04 #>  [3,] 0.5773504 0.5773499 0.0003781631 6.544247e-04 #>  [4,] 0.5773503 0.5773502 0.0001937478 6.184941e-05 #>  [5,] 0.5773506 0.5773497 0.0005334465 8.832914e-04 #>  [6,] 0.5773509 0.5773490 0.0010955691 9.670590e-04 #>  [7,] 0.5773504 0.5773499 0.0005396455 5.466574e-04 #>  [8,] 0.5773504 0.5773500 0.0005112188 4.060530e-04 #>  [9,] 0.5773503 0.5773502 0.0001481320 1.383944e-04 #> [10,] 0.5773503 0.5773501 0.0003840209 3.287748e-04  ## NB: in the above, take a transpose because the *rows* of A are 4-vectors.  ## Then reflect the photons in the mirror: reflect(A %*% t(B),m) #>               E       p_x        p_y        p_z #>  [1,] 0.5773506 0.1915450 -0.3855242 -0.3847276 #>  [2,] 0.5773505 0.1916777 -0.3847158 -0.3854699 #>  [3,] 0.5773504 0.1917616 -0.3852102 -0.3849339 #>  [4,] 0.5773503 0.1922797 -0.3848768 -0.3850087 #>  [5,] 0.5773506 0.1915054 -0.3853108 -0.3849610 #>  [6,] 0.5773509 0.1910746 -0.3851789 -0.3853074 #>  [7,] 0.5773504 0.1917258 -0.3850845 -0.3850775 #>  [8,] 0.5773504 0.1918385 -0.3850003 -0.3851055 #>  [9,] 0.5773503 0.1922591 -0.3849430 -0.3849528 #> [10,] 0.5773503 0.1919748 -0.3849913 -0.3850465   ## Now transform back to the original rest frame (NB: active transform): A |> tcrossprod(B) |> reflect(m) |> tcrossprod(solve(B)) #>               t         x          y          z #>  [1,] 0.7772557 0.5545107 -0.3855242 -0.3847276 #>  [2,] 0.7773322 0.5546639 -0.3847158 -0.3854699 #>  [3,] 0.7773805 0.5547606 -0.3852102 -0.3849339 #>  [4,] 0.7776794 0.5553588 -0.3848768 -0.3850087 #>  [5,] 0.7772327 0.5544649 -0.3853108 -0.3849610 #>  [6,] 0.7769843 0.5539676 -0.3851789 -0.3853074 #>  [7,] 0.7773598 0.5547193 -0.3850845 -0.3850775 #>  [8,] 0.7774248 0.5548494 -0.3850003 -0.3851055 #>  [9,] 0.7776675 0.5553350 -0.3849430 -0.3849528 #> [10,] 0.7775035 0.5550068 -0.3849913 -0.3850465"},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":null,"dir":"Reference","previous_headings":"","what":"seq method for three velocities — seq.3vel","title":"seq method for three velocities — seq.3vel","text":"Simplified version seq() three-velocities.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"seq method for three velocities — seq.3vel","text":"","code":"# S3 method for 3vel seq(from, to, len, ...)"},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"seq method for three velocities — seq.3vel","text":",Start end sequence len Length vector returned ... arguments (currently ignored)","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"seq method for three velocities — seq.3vel","text":"seq(,b,n) returns + t*(-b+) t   numeric vector seq(=0,=1,len=n). definition one several plausible alternatives,   nice property first last elements exactly equal   b respectively.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"seq method for three velocities — seq.3vel","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"seq method for three velocities — seq.3vel","text":"","code":"a <- as.3vel(c(4,5,6)/9) b <- as.3vel(c(-5,6,8)/14) x <- seq(a,b,len=9)  x[1]-a # should be zero #> A vector of three-velocities (speed of light = 1) #>      x y z #> [1,] 0 0 0 x[9]-b # should be zero #> A vector of three-velocities (speed of light = 1) #>                x             y             z #> [1,] 2.22201e-15 -8.428313e-16 -1.072694e-15   jj <- a + seq(0,1,len=9)*(b-a)  jj-x   # decidedly non-zero #> A vector of three-velocities (speed of light = 1) #>                 x         y         z #>  [1,]  0.00000000 0.0000000 0.0000000 #>  [2,] -0.04838804 0.1181117 0.1533975 #>  [3,] -0.03232101 0.2418630 0.3086692 #>  [4,]  0.03217792 0.3559577 0.4477686 #>  [5,]  0.11675360 0.4488587 0.5584128 #>  [6,]  0.19150356 0.5159410 0.6371904 #>  [7,]  0.23782735 0.5594566 0.6884694 #>  [8,]  0.25335939 0.5854552 0.7200976 #>  [9,]  0.24656019 0.6002548 0.7393787"},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":null,"dir":"Reference","previous_headings":"","what":"The energy-momentum tensor — transform","title":"The energy-momentum tensor — transform","text":"Various functionality deal stress-energy tensor   special relativity.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The energy-momentum tensor — transform","text":"","code":"perfectfluid(rho,p,u=0) dust(rho,u=0) photongas(rho,u=0) transform_dd(TT, B) transform_ud(TT, B) transform_uu(TT, B) raise(TT) lower(TT)"},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The energy-momentum tensor — transform","text":"TT second-rank tensor indices either     downstairs-downstairs, downstairs-upstairs, upstairs-upstairs B boost matrix rho,p,u Density, pressure, four-velocity dust","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The energy-momentum tensor — transform","text":"Function perfectfluid() returns stress-energy tensor,   two upstairs indices, perfect fluid conditions   specified.  checking physical reasonableness (eg weak   energy condition) performed: caveat emptor! Function dust() (trivial) function returns   stress-energy tensor zero-pressure perfect fluid (, dust).   Function photongas() returns stress-energy tensor   photon gas.  discoverability reasons;   special cases perfect fluid. Functions transform_dd() et seq transform second-rank tensor   using Lorentz transform.  letters “u” “d”   denote indices tensor upstairs (contravariant)   downstairs (covariant).  stress-energy tensor usually written   two upstairs indices, use transform_uu() transform   . Function lower() lowers indices tensor two   upstairs indices.  Function raise() raises two downstairs   indices.  two functions identical R idiom return   identical values \\(c\\neq 1\\).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The energy-momentum tensor — transform","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The energy-momentum tensor — transform","text":"","code":"perfectfluid(10,1) #>    t x y z #> t 10 0 0 0 #> x  0 1 0 0 #> y  0 0 1 0 #> z  0 0 0 1  u <- as.3vel(c(0.4,0.4,0.2))  ## In the following, LHS is stationary dust and RHS is dust moving at ## velocity 'u', but transformed to a frame also moving at velocity 'u':  LHS <- dust(1) RHS <- transform_uu(dust(1,u),boost(u)) max(abs(LHS-RHS))  # should be small #> [1] 6.938894e-17   ## In the following, negative sign needed because active/passive ## difference:  LHS <- dust(1,u) RHS <- transform_uu(dust(1),boost(-u)) max(abs(LHS-RHS))  # should be small #> [1] 0  ## Now test behaviour when  c!=1:   sol(299792458) #> [1] 299792458 perfectfluid(1.225,101325) # air at STP #>       t            x            y            z #> t 1.225 0.000000e+00 0.000000e+00 0.000000e+00 #> x 0.000 1.127393e-12 0.000000e+00 0.000000e+00 #> y 0.000 0.000000e+00 1.127393e-12 0.000000e+00 #> z 0.000 0.000000e+00 0.000000e+00 1.127393e-12  LHS <- transform_uu(perfectfluid(1.225,101325),boost(as.3vel(c(1000,0,0)))) RHS <- perfectfluid(1.225,101325)  LHS-RHS  # should be small #>               t       x y z #> t  1.362999e-11   -1225 0 0 #> x -1.225000e+03 1225000 0 0 #> y  0.000000e+00       0 0 0 #> z  0.000000e+00       0 0 0  sol(10) #> [1] 10 u <- as.3vel(4:6) LHS <- photongas(1,u) RHS <- transform_uu(photongas(1),boost(-u)) LHS-RHS # should be small #>               t             x             y             z #> t -8.881784e-16 -3.552714e-15  3.552714e-15  0.000000e+00 #> x -3.552714e-15  0.000000e+00  1.421085e-14  0.000000e+00 #> y  3.552714e-15  1.421085e-14  1.421085e-14 -2.842171e-14 #> z  0.000000e+00  0.000000e+00 -2.842171e-14 -2.842171e-14    B1 <- boost(r3vel(1)) %*% boost(r3vel(1)) B2 <- boost(r3vel(1)) %*% boost(r3vel(1)) LHS <- transform_uu(transform_uu(dust(1),B1),B2) RHS <- transform_uu(dust(1),B2 %*% B1)   # note order LHS-RHS  # should be small #>               t             x            y             z #> t  0.000000e+00  2.220446e-16 0.000000e+00  0.000000e+00 #> x  2.220446e-16 -2.220446e-16 2.664535e-15  3.552714e-15 #> y  0.000000e+00  8.881784e-16 7.105427e-15 -1.421085e-14 #> z -7.105427e-15  1.776357e-15 0.000000e+00  2.842171e-14   ## remember to re-set c: sol(1) #> [1] 1"},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":null,"dir":"Reference","previous_headings":"","what":"Speed of light and Minkowski metric — sol","title":"Speed of light and Minkowski metric — sol","text":"Getting setting speed light","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Speed of light and Minkowski metric — sol","text":"","code":"sol(c) eta(downstairs=TRUE) ptm(to_natural=TRUE, change_time=TRUE)"},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Speed of light and Minkowski metric — sol","text":"c Scalar, speed light.  missing, return speed     light downstairs Boolean, default TRUE meaning return     covariant metric tensor \\(g_{ij}\\) two downstairs       indices, FALSE meaning return contravariant       version \\(g^{ij}\\) two upstairs indices to_natural,change_time Boolean, specifying       nature passive transform matrix","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Speed of light and Minkowski metric — sol","text":"context R package, symbol “c” presents   particular problems.  lorentz package, speed light   denoted “sol”, ‘speed light’.  can set   speed light sol(x), query sol(); see   examples.  infinite speed light sometimes useful   Galilean transforms. speed light global variable, governed   options(\"c\").  NULL, define c=1.  Setting   showSOL TRUE makes sol() change prompt   display speed light might useful. Function eta() returns Minkowski flat-space metric   $$\\mathrm{diag}\\left(-c^2,1,1,1\\right).$$ Note top-left element eta() \\(-c^2\\),   \\(-1\\). Function ptm() returns passive transformation matrix   converts displacement vectors natural units   (to_natural=TRUE) natural units   (to_natural=FALSE).  Argument change_time specifies   whether change unit time (TRUE) unit   length (FALSE).","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Speed of light and Minkowski metric — sol","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Speed of light and Minkowski metric — sol","text":"Typing “sol(299792458)” lot easier typing   “options(\"c\"=299792458)”, package uses   idiom . R-devel discussion options printing, Martin Maechler   makes following observation: “Good programming style   functions according book depend   arguments, global option really (really? think twice!)   influence behavior, arguments function   default determined global option” think right general, offer observation   speed light depends units chosen, typically one fixes   one's units , subsequently change .   indicate (least) global option   appropriate.  , default, \\(c=1\\),   returned sol() option unset.  just   “default”, though: used overwhelming majority   cases.  Indeed, pedagogically speaking, one learning objective   package units \\(c\\neq 1\\) difficult,   awkward, unnatural.  package R code,   place speed light option accessed via   sol().  Similar arguments presented clifford   package signature.Rd.","code":""},{"path":"https://robinhankin.github.io/lorentz/reference/sol.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Speed of light and Minkowski metric — sol","text":"","code":"sol()                          # returns current speed of light #> [1] 1 sol(299792458)                 # use SI units #> [1] 299792458 sol()                          # speed of light now SI value #> [1] 299792458  eta()                          # note [t,t] term #>               [,1] [,2] [,3] [,4] #> [1,] -8.987552e+16    0    0    0 #> [2,]  0.000000e+00    1    0    0 #> [3,]  0.000000e+00    0    1    0 #> [4,]  0.000000e+00    0    0    1 u <- as.3vel(c(100,200,300))   # fast terrestrial speed, but not relativistic boost(u)                       # boost matrix practically Galilean #>      t             x            y             z #> t    1 -1.112650e-15 -2.22530e-15 -3.337950e-15 #> x -100  1.000000e+00  1.11265e-13  1.668975e-13 #> y -200  1.112650e-13  1.00000e+00  3.337950e-13 #> z -300  1.668975e-13  3.33795e-13  1.000000e+00 is.consistent.boost(boost(u))  # should be TRUE #> [1] TRUE sol(1)                         # revert to relativistic units #> [1] 1"}]
